[#](#Expression-evaluation) Expression evaluation
=================

In TRM, the values in the registers (including the PC) and memory uniquely determine one unique state of the computer. So it stands to reason that printing the registers and scanning the memory must be able to help us debug all the problems. But for ease of use, we also want the simple debugger to help us compute expressions with registers and memory. That's why you need to add expression evaluation functionality to the simple debugger. For the sake of simplicity, let's consider the implementation of math expression evaluation first.

### [#](#Mathematical-expression-evaluation) Mathematical expression evaluation

You are given a string of expressions

    "5 + 4 * 3 / 2 - 1"
    

How do you find its value? Expression evaluation is such a classic problem that there are many ways to solve it. We have weighed the knowledge required against the difficulty, and here we use the following approach to solving expression evaluation: 

1. first identify all the units in the expression
2. recursively evaluate the expression according to its inductive definition.

#### [#](#Lexical-Analysis) Lexical Analysis

"Lexical analysis" is a fancy word for doing the first thing above, "identifying all the units in an expression". A "unit" in this case is a substring with its own meaning, formally known as a token. Specifically, we need to identify the tokens `5`, `+`, `4`, `*`, `3`, `/`, `2`, `-`, and `1` in the above expression. You might think that's a pretty simple thing to do, but consider the following expression.

    "0x80100000+   ($a0 +5)*4 - *(  $t1 + 8) + number"
    

It contains many more features, such as hexadecimal integers (`0x80100000`), parentheses, access to registers (`$a0`), pointer dereferencing (the second `*`), and access to variables (`number`). In fact, such complex expressions are often used during debugging, and you need to be able to correctly recognize tokens with a variable number of spaces (zero or more). Of course, you can still do this manually (if you like challenging work), and a quicker and easier way to do it is to use regular expressions. Regular expressions make it easy to match complex patterns and are a must for programmers. If you've never encountered regular expressions before, please STFW. In the experiment, you just need to understand some basic knowledge of regular expressions (such as metacharacters).

Once you've learned how to use simple regular expressions, you can start thinking about how to use regular expressions to recognize tokens. Let's start with a simple case - an arithmetic expression, where only the following token types are allowed in the expression to be evaluated.
* decimal integers
* `+`, `-`, `*`, `/`
* `(`, `)`.
* A collection of spaces  (one or more spaces).

First we need to write rules to recognize each of these token types using regular expressions. In the framework code, a rule is a pair (implemented with C struct) consisting of a regular expression and a token type. The framework code already gives rules for `+` and collection of spaces, where the token type for collection of spaces is `TK_NOTYPE`, since collection of spaces don't take part in the evaluation process and can be discarded once recognized, and the token type for `+` is `'+'`. In fact, the token type is just an integer, so just make sure that different types of tokens are encoded as different integers. There is also a rule in the framework code that recognizes double equals signs, but we can ignore it for now.

These rules are compiled via `init_regex()` during the initialization of the simple debugger into some internal data structure for pattern matching, which are used by the library functions, and which are used over and over again, but you don't have to worry about how they are organized. However, if the compilation of the regular expression fails, NEMU will trigger an assertion fail, in which case you need to check that the rules you've written conform to the syntax of the regular expression.

Given an expression to be evaluated, we first need to recognize the tokens in it, and this is done by the `make_token()` function. The `make_token()` function works in a very straightforward way, it uses the `position` variable to indicate where it is currently processing, and it tries to match the string at the current position with all the rules in order. When a rule matches successfully, and the matched substring is exactly where `position` is, we have successfully recognized a token, and the `Log()` macro outputs a message that the recognition was successful. All you need to do is save the information about the recognized token (with the exception of the space string), and we use the `Token` structure to save the token information:

    typedef struct token {
      int type;
      char str[32];
    } Token;
    

The `type` member is used to record the type of the token. For most tokens it is sufficient to just record the type, e.g. `+`, `-`, `*`, `/`, but this is not sufficient for some tokens: if we only record the type of a decimal integer token, then when evaluating the token we will still have no idea of what the decimal integer is. We should record the corresponding substring of the token, and the `str` member is used to do this. Note that the `str` member has a finite length, so when you realize that the buffer is about to overflow, you should handle it accordingly (think about it, how would you handle it?) , otherwise it will result in some hard to find bug. The `tokens` array is used to store the recognized tokens in order, and `nr_token` indicates the number of recognized tokens.

If all the rules tried can not match the token at the current position, the recognition fails, and the framework code outputs the current position of the token (when the expression is too long and requires line breaks in the terminal, `^` may not indicate the correct position, and it is recommended to locate the position of the token by the output `position` value). This is usually the result of a ill-formed expression, and the `make_token()` function will return `false`, indicating that the lexical analysis failed.

#### 实现算术表达式的词法分析

你需要完成以下的内容:

*   为算术表达式中的各种token类型添加规则, 你需要注意C语言字符串中转义字符的存在和正则表达式中元字符的功能.
*   在成功识别出token后, 将token的信息依次记录到`tokens`数组中.

#### 调试公理

*   The machine is always right. (机器永远是对的)
    *   Corollary: If the program does not produce the desired output, it is the programmer's fault.
*   Every line of untested code is always wrong. (未测试代码永远是错的)
    *   Corollary: Mistakes are likely to appear in the "must-be-correct" code.

这两条公理的意思是: 抱怨是没有用的, 接受代码有bug的现实, 耐心调试.

jyy曾经将它们作为fact提出. 事实上无数程序员(包括你的学长学姐)在实践当中一次又一次验证了它们的正确性, 因此它们在这里作为公理出现.

#### 如何调试

*   不要使用"目光调试法", 要思考如何用正确的工具和方法帮助调试
    *   程序设计课上盯着几十行的程序, 你或许还能在大脑中像NEMU那样模拟程序的执行过程; 但程序规模大了之后, 很快你就会放弃的: 你的大脑不可能模拟得了一个巨大的状态机
    *   我们学习计算机是为了学习计算机的工作原理, 而不是学习如何像计算机那样机械地工作
*   使用`assert()`设置检查点, 拦截非预期情况
    *   例如`assert(p != NULL)`就可以拦截由空指针解引用引起的段错误
*   结合对程序执行行为的理解, 使用`printf()`查看程序执行的情况(注意字符串要换行)
    *   `printf()`输出任意信息可以检查代码可达性: 输出了相应信息, 当且仅当相应的代码块被执行
    *   `printf()`输出变量的值, 可以检查其变化过程与原因
*   使用GDB观察程序的任意状态和行为
    *   打印变量, 断点, 监视点, 函数调用栈...

如果你突然觉得上述方法很有道理, 说明你在程序设计课上没有受到该有的训练.

#### 为什么printf()的输出要换行?

如果不换行, 可能会发生什么? 你可以在代码中尝试一下, 并思考原因, 然后STFW对比你的想法.

#### 系统设计的黄金法则 -- KISS法则

这里的`KISS`是`Keep It Simple, Stupid`的缩写, 它的中文翻译是: 不要在一开始追求绝对的完美.

你已经学习过程序设计基础, 这意味着你已经学会写程序了, 但这并不意味着你可以顺利地完成PA, 因为在现实世界中, 我们需要的是可以运行的system, 而不是求阶乘的小程序. NEMU作为一个麻雀虽小, 五脏俱全的小型系统, 其代码量达到3000多行(不包括空行). 随着PA的进行, 代码量会越来越多, 各个模块之间的交互也越来越复杂, 工程的维护变得越来越困难, 一个很弱智的bug可能需要调好几天. 在这种情况下, 系统能跑起来才是王道, 跑不起来什么都是浮云, 追求面面俱到只会增加代码维护的难度.

唯一可以把你从bug的混沌中拯救出来的就是KISS法则, 它的宗旨是**从易到难, 逐步推进**, 一次只做一件事, 少做无关的事. 如果你不知道这是什么意思, 我们以上文提到的`str`成员缓冲区溢出问题来作为例子. KISS法则告诉你, 你应该使用`assert(0)`, 就算不"得体"地处理上述问题, 仍然不会影响表达式求值的核心功能的正确性. 如果你还记得调试公理, 你会发现两者之间是有联系的: 调试公理第二点告诉你, 未测试代码永远是错的. 与其一下子写那么多"错误"的代码, 倒不如使用`assert(0)`来有效帮助你减少这些"错误".

如果把KISS法则放在软件工程领域来解释, 它强调的就是多做[单元测试open in new window](https://en.wikipedia.org/wiki/Unit_testing): 写一个函数, 对它进行测试, 正确之后再写下一个函数, 再对它进行测试... 一种好的测试方式是使用assertion进行验证, `reg_test()`就是这样的例子. 学会使用assertion, 对程序的测试和调试都百利而无一害.

KISS法则不但广泛用在计算机领域, 就连其它很多领域也视其为黄金法则, [这里open in new window](http://blog.sciencenet.cn/blog-414166-562616.html)有一篇文章举出了很多的例子, 我们强烈建议你阅读它, 体会KISS法则的重要性.

#### [#](#递归求值) 递归求值

把待求值表达式中的token都成功识别出来之后, 接下来我们就可以进行求值了. 需要注意的是, 我们现在是在对tokens数组进行处理, 为了方便叙述, 我们称它为"token表达式". 例如待求值表达式

    "4 +3*(2- 1)"
    

的token表达式为

    +-----+-----+-----+-----+-----+-----+-----+-----+-----+
    | NUM | '+' | NUM | '*' | '(' | NUM | '-' | NUM | ')' |
    | "4" |     | "3" |     |     | "2" |     | "1" |     |
    +-----+-----+-----+-----+-----+-----+-----+-----+-----+
    

根据表达式的归纳定义特性, 我们可以很方便地使用递归来进行求值. 首先我们给出算术表达式的归纳定义:

    <expr> ::= <number>    # 一个数是表达式
      | "(" <expr> ")"     # 在表达式两边加个括号也是表达式
      | <expr> "+" <expr>  # 两个表达式相加也是表达式
      | <expr> "-" <expr>  # 接下来你全懂了
      | <expr> "*" <expr>
      | <expr> "/" <expr>
    

上面这种表示方法就是大名鼎鼎的[BNFopen in new window](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form), 任何一本正规的程序设计语言教程都会使用BNF来给出这种程序设计语言的语法.

根据上述BNF定义, 一种解决方案已经逐渐成型了: 既然长表达式是由短表达式构成的, 我们就先对短表达式求值, 然后再对长表达式求值. 这种十分自然的解决方案就是[分治法open in new window](https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms)的应用, 就算你没听过这个高大上的名词, 也不难理解这种思路. 而要实现这种解决方案, 递归是你的不二选择.

为了在token表达式中指示一个子表达式, 我们可以使用两个整数`p`和`q`来指示这个子表达式的开始位置和结束位置. 这样我们就可以很容易把求值函数的框架写出来了:

    eval(p, q) {
      if (p > q) {
        /* Bad expression */
      }
      else if (p == q) {
        /* Single token.
         * For now this token should be a number.
         * Return the value of the number.
         */
      }
      else if (check_parentheses(p, q) == true) {
        /* The expression is surrounded by a matched pair of parentheses.
         * If that is the case, just throw away the parentheses.
         */
        return eval(p + 1, q - 1);
      }
      else {
        /* We should do more things here. */
      }
    }
    

其中`check_parentheses()`函数用于判断表达式是否被一对匹配的括号包围着, 同时检查表达式的左右括号是否匹配, 如果不匹配, 这个表达式肯定是不符合语法的, 也就不需要继续进行求值了. 我们举一些例子来说明`check_parentheses()`函数的功能:

    "(2 - 1)"             // true
    "(4 + 3 * (2 - 1))"   // true
    "4 + 3 * (2 - 1)"     // false, the whole expression is not surrounded by a matched
                          // pair of parentheses
    "(4 + 3)) * ((2 - 1)" // false, bad expression
    "(4 + 3) * (2 - 1)"   // false, the leftmost '(' and the rightmost ')' are not matched
    

至于怎么检查左右括号是否匹配, 就当作一个程序设计作业, 留给聪明的你来思考吧!

上面的框架已经考虑了BNF中算术表达式的开头两种定义, 接下来我们来考虑剩下的情况(即上述伪代码中最后一个`else`中的内容). 一个问题是, 给出一个最左边和最右边不同时是括号的长表达式, 我们要怎么正确地将它分裂成两个子表达式? 我们定义"主运算符"为表达式人工求值时, 最后一步进行运行的运算符, 它指示了表达式的类型(例如当一个表达式的最后一步是减法运算时, 它本质上是一个减法表达式). 要正确地对一个长表达式进行分裂, 就是要找到它的主运算符. 我们继续使用上面的例子来探讨这个问题:

    "4 + 3 * ( 2 - 1 )"
    /*********************/
    case 1:
        "+"
       /   \
    "4"     "3 * ( 2 - 1 )"
    
    
    case 2:
            "*"
           /   \
    "4 + 3"     "( 2 - 1 )"
    
    
    case 3:
                  "-"
                 /   \
    "4 + 3 * ( 2"     "1 )"
    

上面列出了3种可能的分裂, 注意到我们不可能在非运算符的token处进行分裂, 否则分裂得到的结果均不是合法的表达式. 根据主运算符的定义, 我们很容易发现, 只有第一种分裂才是正确的. 这其实也符合我们人工求值的过程: 先算`4`和`3 * ( 2 - 1 )`, 最后把它们的结果相加. 第二种分裂违反了算术运算的优先级, 它会导致加法比乘法更早进行. 第三种分裂破坏了括号的平衡, 分裂得到的结果均不是合法的表达式.

通过上面这个简单的例子, 我们就可以总结出如何在一个token表达式中寻找主运算符了:

*   非运算符的token不是主运算符.
*   出现在一对括号中的token不是主运算符. 注意到这里不会出现有括号包围整个表达式的情况, 因为这种情况已经在`check_parentheses()`相应的`if`块中被处理了.
*   主运算符的优先级在表达式中是最低的. 这是因为主运算符是最后一步才进行的运算符.
*   当有多个运算符的优先级都是最低时, 根据结合性, 最后被结合的运算符才是主运算符. 一个例子是`1 + 2 + 3`, 它的主运算符应该是右边的`+`.

要找出主运算符, 只需要将token表达式全部扫描一遍, 就可以按照上述方法唯一确定主运算符.

找到了正确的主运算符之后, 事情就变得很简单了: 先对分裂出来的两个子表达式进行递归求值, 然后再根据主运算符的类型对两个子表达式的值进行运算即可. 于是完整的求值函数如下:

    eval(p, q) {
      if (p > q) {
        /* Bad expression */
      }
      else if (p == q) {
        /* Single token.
         * For now this token should be a number.
         * Return the value of the number.
         */
      }
      else if (check_parentheses(p, q) == true) {
        /* The expression is surrounded by a matched pair of parentheses.
         * If that is the case, just throw away the parentheses.
         */
        return eval(p + 1, q - 1);
      }
      else {
        op = the position of 主运算符 in the token expression;
        val1 = eval(p, op - 1);
        val2 = eval(op + 1, q);
    
        switch (op_type) {
          case '+': return val1 + val2;
          case '-': /* ... */
          case '*': /* ... */
          case '/': /* ... */
          default: assert(0);
        }
      }
    }
    

需要注意的是, 上述框架中并没有进行错误处理, 在求值过程中发现表达式不合法的时候, 应该给上层函数返回一个表示出错的标识, 告诉上层函数"求值的结果是无效的". 例如在`check_parentheses()`函数中, `(4 + 3)) * ((2 - 1)`和`(4 + 3) * (2 - 1)`这两个表达式虽然都返回`false`, 因为前一种情况是表达式不合法, 是没有办法成功进行求值的; 而后一种情况是一个合法的表达式, 是可以成功求值的, 只不过它的形式不属于BNF中的`"(" <expr> ")"`, 需要使用主运算符的方式进行处理, 因此你还需要想办法把它们区别开来. 当然, 你也可以在发现非法表达式的时候使用`assert(0)`终止程序. 不过这样的话, 你在使用表达式求值功能的时候就要十分谨慎了.

最后, 为了方便统一, 我们认为所有结果都是`uint32_t`类型.

#### 实现算术表达式的递归求值

由于ICS不是算法课, 我们已经把递归求值的思路和框架都列出来了. 你需要做的是理解这一思路, 然后在框架中填充相应的内容. 实现表达式求值的功能之后, `p`命令也就不难实现了.

#### 实现带有负数的算术表达式的求值 (选做)

在上述实现中, 我们并没有考虑负数的问题, 例如

    "1 + -1"
    "--1"    /* 我们不实现自减运算, 这里应该解释成 -(-1) = 1 */
    

它们会被判定为不合法的表达式. 为了实现负数的功能, 你需要考虑两个问题:

*   负号和减号都是`-`, 如何区分它们?
*   负号是个单目运算符, 分裂的时候需要注意什么?

你可以选择不实现负数的功能, 但你很快就要面临类似的问题了.

#### 从表达式求值窥探编译器

你在程序设计课上已经知道, 编译是一个将高级语言转换成机器语言的过程. 但你是否曾经想过, 机器是怎么读懂你的代码的? 回想你实现表达式求值的过程, 你是否有什么新的体会?

事实上, 词法分析也是编译器编译源代码的第一个步骤, 编译器也需要从你的源代码中识别出token, 这个功能也可以通过正则表达式来完成, 只不过token的类型更多, 更复杂而已. 这也解释了你为什么可以在源代码中插入任意数量的空白字符(包括空格, tab, 换行), 而不会影响程序的语义; 你也可以将所有源代码写到一行里面, 编译仍然能够通过.

一个和词法分析相关的有趣的应用是语法高亮. 在程序设计课上, 你可能完全没有想过可以自己写一个语法高亮的程序. 事实是, 这些看似这么神奇的东西, 其实也没那么复杂, 你现在确实有能力来实现它: 把源代码看作一个字符串输入到语法高亮程序中, 在循环中识别出一个token之后, 根据token类型用不同的颜色将它的内容重新输出一遍就可以了. 如果你打算将高亮的代码输出到终端里, 你可以使用[ANSI转义码的颜色功能open in new window](https://en.wikipedia.org/wiki/ANSI_escape_code#Colors).

在表达式求值的递归求值过程中, 逻辑上其实做了两件事情: 第一件事是根据token来分析表达式的结构(属于BNF中的哪一种情况), 第二件事才是求值. 它们在编译器中也有对应的过程: 语法分析就好比分析表达式的结构, 只不过编译器分析的是程序的结构, 例如哪些是函数, 哪些是语句等等. 当然程序的结构要比表达式的结构更复杂, 因此编译器一般会使用一种标准的框架来分析程序的结构, 理解这种框架需要更多的知识, 这里就不展开叙述了. 另外如果你有兴趣, 可以看看C语言语法的BNF.

和表达式最后的求值相对的, 在编译器中就是代码生成. ICS理论课会有专门的章节来讲解C代码和汇编指令的关系, 即使你不了解代码具体是怎么生成的, 你仍然可以理解它们之间的关系. 这是因为C代码天生就和汇编代码有密切的联系, 高水平C程序员的思维甚至可以在C代码和汇编代码之间相互转换. 如果要深究代码生成的过程, 你也不难猜到是用递归实现的: 例如要生成一个函数的代码, 就先生成其中每一条语句的代码, 然后通过某种方式将它们连接起来.

我们通过表达式求值的实现来窥探编译器的组成, 是为了落实一个道理: 学习汽车制造专业不仅仅是为了学习开汽车, 是要学习发动机怎么设计. 我们也强烈推荐你在将来修读"编译原理"课程, 深入学习"如何设计发动机".

### [#](#如何测试你的代码) 如何测试你的代码

你将来是要使用你自己实现的表达式求值功能来帮助你来进行后续的调试的, 这意味着程序设计课上那种"代码随便测试一下就交上去然后就可以撒手不管"的日子已经一去不复返了. 测试需要测试用例, 通过越多测试, 你就会对代码越有信心. 但如果让你来设计测试用例, 设计十几个你就会觉得没意思了, 有没有一种方法来自动产生测试用例呢?

一种常用的方法是[随机测试open in new window](https://en.wikipedia.org/wiki/Random_testing). 首先我们需要来思考如何随机生成一个合法的表达式. 事实上, 表达式生成比表达式求值要容易得多. 同样是上面的BNF, 我们可以很容易写出生成表达式的框架:

    void gen_rand_expr() {
      switch (choose(3)) {
        case 0: gen_num(); break;
        case 1: gen('('); gen_rand_expr(); gen(')'); break;
        default: gen_rand_expr(); gen_rand_op(); gen_rand_expr(); break;
      }
    }
    

你应该一眼就能明白上述代码是如何工作的: 其中`uint32_t choose(uint32_t n)`是一个很简单又很重要的函数, 它的作用是生成一个小于`n`的随机数, 所有随机生成的内容几乎都是通过它来选择的.

有了这些随机表达式作为测试输入, 我们怎么知道输出对不对呢? 如果要我们把这些表达式手动算一遍, 那就太麻烦了. 如果可以在生成这些表达式的同时, 也能生成它们的结果, 这样我们就能得到类似OJ的测试用例啦! 但我们在NEMU中实现的表达式求值是经过了一些简化的, 所以我们需要一种满足以下条件的"计算器":

*   进行的都是无符号运算
*   数据宽度都是32bit
*   溢出后不处理

嘿! 如果我们把这些表达式塞到如下C程序的源文件里面:

    #include <stdio.h>
    int main() {
      unsigned result = ???; // 把???替换成表达式
      printf("%u", result);
      return 0;
    }
    

然后用gcc编译它并执行, 让它输出表达式的结果, 这不就是我们想要的"计算器"吗?

还真能这样做! 我们已经准备好这个表达式生成器的框架代码了(在`nemu/tools/gen-expr/gen-expr.c`中). 你需要实现其中的`void gen_rand_expr()`函数, 将随机生成的表达式输出到缓冲区`buf`中. `main`函数中的代码会调用你实现的`gen_rand_expr()`, 然后把`buf`中的随机表达式放入上述C程序的代码中. 剩下的事情就是编译运行这个C程序了, 代码中使用了`system()`和`popen()`等库函数来实现这一功能. 最后, 框架代码将这个C程序的打印结果和之前随机生成的表达式一同输出, 这样就生成了一组测试用例.

#### 表达式生成器如何获得C程序的打印结果?

代码中这部分的内容没有任何注释, 聪明的你也许马上就反应过来: 竟然是个RTFM的圈套! 阅读手册了解API的具体行为可是程序员的基本功. 如果觉得去年一整年的程序员都白当了, 就从现在开始好好锻炼吧.

不过实现的时候, 你很快就会发现需要面对一些细节的问题:

*   如何保证表达式进行无符号运算?
*   如何随机插入空格?
*   如何生成长表达式, 同时不会使`buf`溢出?
*   如何过滤求值过程中有除0行为的表达式?

这些问题大多都和C语言相关, 就当作是C语言的又一个编程练习吧.

#### 为什么要使用无符号类型? (建议二周目思考)

我们在表达式求值中约定, 所有运算都是无符号运算. 你知道为什么要这样约定吗? 如果进行有符号运算, 有可能会发生什么问题?

#### 除0的确切行为

如果生成的表达式有除0行为, 你编写的表达式生成器的行为又会怎么样呢?

#### 过滤除0行为的表达式

乍看之下这个问题不好解决, 因为框架代码只负责生成表达式, 而检测除0行为至少要对表达式进行求值. 结合前两个蓝框题的回答(前提是你对它们的理解都足够深入了), 你就会找到解决方案了, 而且解决方案不唯一喔!

#### 实现表达式生成器

根据上文内容, 实现表达式生成器. 实现后, 就可以用来生成表达式求值的测试用例了.

    ./gen-expr 10000 > input
    

将会生成10000个测试用例到`input`文件中, 其中每行为一个测试用例, 其格式为

    结果 表达式
    

再稍微改造一下NEMU的`main()`函数, 让其读入`input`文件中的测试表达式后, 直接调用`expr()`, 并与结果进行比较. 为了容纳长表达式的求值, 你还需要对`tokens`数组的大小进行修改.

随着你的程序通过越来越多的测试, 你会对你的代码越来越有信心.

#### 温馨提示

PA1阶段2到此结束.

[基础设施: 简易调试器](/docs/ics-pa/1.4.html) [监视点](/docs/ics-pa/1.6.html)
