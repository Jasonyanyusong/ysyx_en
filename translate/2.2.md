[#](2.2.html#rtfm) RTFM
=======================

We've already covered the concepts of how an instruction is executed in the previous section, some of which are even hard to expand on. But when we decided to add all kinds of efficient instructions to TRM, it also meant that we couldn't avoid the complexity of the details.

The first thing you need to know is the exact behavior of the instructions, and for that you need to read the instruction set section of the survival manual (The official ISA manual). Specifically, whatever ISA you choose, the corresponding manual will usually have the following, so try to RTFM and look for the location of these.

* A description of the specific behavior of each instruction
* a table of instruction opcodes's encoding

In particular, due to the complexity of the x86 instruction set, we have provided [a simple tutorial](i386-intro.html) for those who choose x86.

#### RISC - Another world parallel to the CISC

Do you think the format of the x86 instruction set is particularly complex? This is actually a characteristic of CISC, using complex instruction format, sacrificing the development cost of hardware, but also to make a single instruction can do more things, so as to increase the density of code, reduce the size of the program. As time progressed, architects realized that the complex control logic in CISC was not conducive to improving processor performance, so RISC was born. The purpose of RISC is simplicity, fewer instructions, fixed instruction length, and uniform instruction format, which is similar to the KISS rule. There is a short article comparing RISC and CISC at [here](http://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc).

Also we recommend [this article](http://blog.sciencenet.cn/blog-414166-763326.html), which tells the story of the birth of the RISC world and its integration with the CISC world, giving a sense of the RISC is a milestone in the evolution of computer architectures. 

If you're lucky enough to choose riscv32, you'll find that you only need to read a very small portion of the manual at this point: in PA, riscv32's client program consists of only two types of instructions, RV32I and RV32M. This is due to the design concept of the RISC-V instruction set - modularity.

#### RISC-V - A well-designed instruction set

RISC-V is a very young instruction set - the first version of RISC-V was proposed by a team of researchers at UC Berkeley in May 2011, and has since taken the world by storm. Openness is RISC-V's biggest selling point, and even ARM and MIPS have been shocked by it, and even try to tearing each other apart for the competition... [This article](http://blog.sciencenet.cn/blog-414166-1089206.html) describes the concept of RISC-V and some of the history of its growth.

Of course, this is not really relevant to PAs in the teaching field. The point is.

* RISC-V is really simple.
* And while it is simple, there are a lot of thoughtful considerations about how the program should run. If you read the RISC-V manual, you'll see that there are a lot of design choices and trade-offs. In addition, Prof. David Patterson (who won the 2018 Turing Award for promoting RISC, and is considered to be one of the great masters in the field of architecture) has also written an introductory book for the promotion of RISC-V, The RISC-V Reader, which describes a large number of RISC-V design principles from a systematic point of view and compares them with the existing instruction set, which is well worth a read. The RISC-V Reader is an introductory book. Three graduate students at the Institute of Computing, Chinese Academy of Sciences, have written a Chinese translation of this book (one of them is also your direct senior), but since this book does not follow the latest contents of the official RISC-V manual, and there are a lot of clerical errors in the book (feel free to raise an issue in the corresponding github repo), we still recommend that you read the official RISC-V manual.

[#](2.2.html#rtfsc-2) RTFSC(2)
------------------------------

After understanding how YEMU executes instructions in the previous subsection, you will have a basic understanding of the emulator's framework. NEMU has to simulate a real ISA, so the code is much more complex than YEMU, but the underlying principles are the same as YEMU. Below we describe how NEMU's framework code implements the execution of commands.

During the course of RTFSC, you will encounter most of the APIs used to abstract ISA differences, so we recommend that you read [this page](nemu-isa-api.html) to get a basic understanding of what these APIs do, so that you can refer to them when you encounter them in your code in the future.

We mentioned in PA1.

> `cpu_exec()` in turn calls `execute()`, which mimics the way the CPU works: executing instructions over and over again. Specifically, the code calls the `exec_once()` function in a for loop, which does what we described in the previous subsection: it tells the CPU to execute an instruction pointed to by the current PC, and then update the PC.

Specifically, `exec_once()` accepts a pointer `s` to a structure of type `Decode`, which is used to hold information needed during the execution of an instruction, including the current PC of the instruction, the PC of the next instruction, etc. There is also some information that is ISA-related, which NEMU abstracts with a structure of type `ISADecodeInfo`, defined in `nemu/src/isa/$ISA/include/isa-def.h`. `exec_once()` first saves the current PC to members `pc` and `snpc` of `s`, where `s->pc` is the PC of the current instruction and `s->snpc` is the PC of the next instruction, where `snpc` means "static next PC".

The code then calls the `isa_exec_once()` function (defined in `nemu/src/isa/$ISA/inst.c`), because the exact process of executing the instruction is ISA-related, so we won't delve into the details of `isa_exec_once()` here. What is clear is that it modifies the value of `s->snpc` as it fetches the instruction, so that `s->snpc` will be the PC for the next instruction when it returns from `isa_exec_once()`. The code will then update the PC with `s->dnpc`, where `dnpc` stands for "dynamic next PC". The difference between `snpc` and `dnpc` is explained below.

Ignoring the rest of the trace-related code in `exec_once()`, we return to `execute()`. The code adds 1 to a counter used to record client instructions, then does some trace and difftest related operations (which we ignore at this point), and then checks to see if the NEMU status is `NEMU_RUNNING`, if it is, it continues with the next instruction, otherwise it exits the loop of executing instructions.

In fact, the `exec_once()` function covers all phases of the instruction cycle: fetch, decode, execute, and update the PC, so let's take a look at how the NEMU implements each phase of the instruction cycle.

### [#](2.2.html#instruction-fetch-if) instruction fetch, IF

The first thing `isa_exec_once()` does is fetch instructions. In NEMU, there is a function `inst_fetch()` (defined in `nemu/include/cpu/ifetch.h`) that does this. `inst_fetch()` ultimately calls `vaddr_ifetch()` (defined in `nemu/src/memory/vaddr.c`) with the parameter `len`, and `vaddr_ifetch()` accesses the contents of physical memory via `paddr_read()`. Thus, an instruction fetch operation is nothing more than a memory access.

`isa_exec_once()` passes in the address of `s->snpc` when calling `inst_fetch()`, so `inst_fetch()` ends up updating `s->snpc` with `len`, which points `s->snpc` to the next instruction.

### [#](2.2.html#instruction-decode-id) instruction decode, ID

The code then goes to the `decode_exec()` function, which first performs decoding-related operations. The purpose of decoding is to get the operation and the oprand of the instruction, which is determined by looking at the `opcode` of the instruction. The `opcode` of different ISAs can be found in different places in the instruction, so we just need to recognize the corresponding `opcode` from the instruction according to the encoding format of the instruction.

Compared with YEMU, NEMU uses a higher level of abstraction: pattern matching, NEMU can specify the `opcode` in an instruction by a pattern string, for example, in riscv32 there is the following pattern: INSTPAT_START(), INSTPAT_START(), INSTPAT_START(), INSTPAT_START().

    INSTPAT_START().
    INSTPAT("??????? ????? ????? ???? ????? 00101 11", aupic, U, R(rd) = s->pc + imm);
    // ...
    INSTPAT_END().

    INSTPAT_START();
    INSTPAT("??????? ????? ????? ??? ????? 00101 11", aupic, U, R(rd) = s->pc + imm);
    // ...
    INSTPAT_END();
    

Where `INSTPAT` (shorthand for instruction pattern) is a macro (defined in `nemu/include/cpu/decode.h`), which is used to define a pattern-matching rule. The format is as follows.

    INSTPAT(pattern string, instruction name, instruction type, instruction execution operation);
    

Only four characters are allowed in the `pattern string`.

* `0`` means that the corresponding bit can only match `0`
* `1` means that the corresponding bit can only match `1`
* `? ` means the corresponding bit can match either `0` or `1`
* Space is a separator, only used to improve the readability of the pattern string, not involved in matching.

The `instruction name' is used only as a comment in the code and does not participate in macro expansion; the `instruction type' is used in the subsequent decoding process; and the `instruction execution operation' is the C code that simulates the real behavior of the instruction execution.

In addition, the macros `INSTPAT_START` and `INSTPAT_END` are defined in `nemu/include/cpu/decode.h`. `INSTPAT` uses two other macros, `INSTPAT_INST` and `INSTPAT_MATCH`, which are defined in `nemu/src/isa/$ISA/inst.c`. After expanding the above code with macros and simply organizing the code, you will end up with.

    { const void ** __instpat_end = &&__instpat_end_;
    do {
      uint64_t key, mask, shift;
      pattern_decode("??????? ????? ????? ??? ????? 00101 11", 38, &key, &mask, &shift);
      if ((((uint64_t)s->isa.inst.val >> shift) & mask) == key) {
        {
          decode_operand(s, &rd, &src1, &src2, &imm, TYPE_U);
          R(rd) = s->pc + imm;
        }
        goto *(__instpat_end);
      }
    } while (0);
    // ...
    __instpat_end_: ; }
    

The `&&__instpat_end_` in the above code uses the [label as values](https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html) extension provided by GCC, and the `goto` statement will jump to the last `__instpat_end_` label. In addition, the `pattern_decode()` function is defined in `nemu/include/cpu/decode.h` and is used to convert pattern strings into three integer variables.

The `pattern_decode()` function extracts the `0` and `1` from the pattern string into the integer variable `key`, with `mask` indicating the mask of the `key`, and `shift` indicating the number of bits away from the lowest bit of the `opcode`, to aid in the optimization by the compiler. Specifically, in the above example.

    key   = 0x17;
    mask  = 0x7f;
    shift = 0;
    

Consider the following instruction from the built-in client program introduced in PA1. 

    0x00000297   auipc t0,0
    

When NEMU fetches the instruction, it will record the instruction into `s->isa.inst.val`, and then the `if` statement in the above macro expansion evals to true, which means that it matches the opcode of the `auipc` instruction, and therefore further decoding operation will be performed.

We only know what the instruction does (e.g. `auipc` adds the current PC value to the immediate number and writes it to a register), but we still don't know what is the oprand (e.g. what the immediate number is, and what register it writes to). To solve this problem, the code needs to be decoded further, which is done by calling the `decode_operand()` function. This function will decode the operands according to the parameter `type` (instruction type), and the result will be recorded in the parameters `rd`, `src1`, `src2`, and `imm`, which represent the register number of the destination operand, the two source operands, and the immediate number, respectively.

We realize that operands such as registers and immediate numbers are very common types of operands. In order to further decouple operand decoding from instruction decoding, we have abstracted and encapsulated the decoding of these operands.

* The framework code defines two helper macros, `src1R()` and `src2R()`, which are used to pass the results of register reads to the corresponding operand variables.
* The framework code also defines helper macros such as `immI`, which are used to extract immediate numbers from instructions.

With these helper macros, we can use them to write `decode_operand()` conveniently, for example, the decoding process of type-I instructions in RISC-V can be realized by the following code:

    case TYPE_I: src1R(); immI(); break;
    

A couple of additional notes.

* `decode_operand` uses the macros `BITS` and `SEXT`, which are defined in `nemu/include/macro.h` and are used for bit extraction and symbol expansion, respectively.
* `decode_operand` will first decode the destination operand through register operands decoding, i.e. call `*rd = BITS(i, 11, 7)`, and `rd` can be used for different types of instructions depending on the situation.
* At the end of the pattern matching process, there is an `inv` rule, which means that "if all the previous pattern matching rules fail to match successfully, then the instruction is considered illegal".

#### Variable-length instructions for x86

Due to the variable-length nature of CISC instructions, x86 instruction lengths and instruction forms need to be determined by fetching and decoding at the same time, unlike the RISC instruction set which handles the fetch and decode phases in a clear-cut manner, so you'll see `inst_fetch()` operations in the x86 decoding process.

#### The Story Behind Immediate Numbers

Framework code through the `inst_fetch()` function to fetch the instructions, even this is only 1 line of code, in fact, behind the scenes, it hides the careful consideration for [endianness](http://en.wikipedia.org/wiki/Endianness). Most of the students' hosts are x86 little-endian machines, when you use high-level language or assembly language to write a 32-bit constant `0x1234`, in the generated binary code, the constant corresponds to the byte sequence as follows (assuming that the constant's starting address in memory is x).

    x   x+1  x+2  x+3
    +----+----+----+----+
    | 34 | 12 | 00 | 00 |
    +----+----+----+----+
    

Whereas most PCs are little-endian architectures (we're sure no students will use an IBM mainframe for PA), when NEMU is running

    imm = inst_fetch(pc, 4);
    
This line of code reads the byte sequence `34 12 00 00` from memory into the `imm` variable as is, and the host CPU interprets this byte sequence in the little-endian fashion, resulting in `0x1234`, which is what we expect.

The processors in the Motorola 68k series are all big-endian architecture. Now the question arises, consider the following two scenarios.

* Suppose we need to run NEMU on a Motorola 68k machine (compiling the NEMU source code into Motorola 68k machine code).
* Suppose we need to add Motorola 68k as a new ISA to NEMU.

In those cases, what problems do you need to be aware of? Why do these problems occur? How to solve them?

The fact is that it is not only the immediate number accesses, but also any memory accesses longer than 1 byte need to be considered similarly. We're going to throw the problems out here, and not discuss them separately in the future.

#### The Story Behind Immediate Numbers (2)

The instruction lengths of mips32 and riscv32 are only 32 bits, so they can't encode 32-bit constants from C code directly into a single instruction like x86 can. Think about it, how should mips32 and riscv32 solve this problem?

#### I'm getting confused by macro definitions, what should I do?

In order to understand the semantics of a macro, you may try to expand it manually, but you may encounter the following difficulties.

* The more macros are nested, the more difficult it is to understand them.
* Some Token-pasting (##) macros can interfere with the editor's go to definition functionality.

In fact, you don't need to do this manually in order to expand macros, because there are tools that can do it: all we need to do is to let GCC output the results of the preprocessing, and then we can see the result of the macro expansion. With the result of the macro expansion, you can quickly understand the semantics of the expansion, and in turn understand how the macro was expanded step-by-step.

Of course, the most convenient way to do this is to let GCC compile NEMU and output the preprocessing results at the same time, which is not difficult if you have some knowledge of the Makefiles.

### [#](2.2.html#执行-execute-ex) 执行(execute, EX)

译码阶段结束之后, 代码将会执行模式匹配规则中指定的`指令执行操作`, 这部分操作会用到译码的结果, 并通过C代码来模拟指令执行的真正行为. 例如对于`auipc`指令, 由于译码阶段已经把U型立即数记录到操作数`imm`中了, 我们只需要通过`R(rd) = s->pc + imm`将立即数与当前PC值相加并写入目标寄存器中, 这样就完成了指令的执行.

指令执行的阶段结束之后, `decode_exec()`函数将会返回`0`, 并一路返回到`exec_once()`函数中. 不过目前代码并没有使用这个返回值, 因此可以忽略它.

### [#](2.2.html#Update-pc) Update PC

Finally, updating the PC. Updating the PC is very simple, just assign `s->dnpc` to `cpu.pc`. We mentioned `snpc` and `dnpc` earlier, so let's explain the difference now.

#### Static and dynamic instructions

In the field of program analysis, static instructions are the instructions in the program code, and dynamic instructions are the instructions during program execution. For example, for the following sequence of instructions

    100: jmp 102
    101: add
    102: xor
    

The next static instruction for the `jmp` instruction is the `add` instruction, and the next dynamic instruction is the `xor` instruction.

With the concepts of static and dynamic instructions, we can explain the difference between `snpc` and `dnpc`: `snpc` is the next static instruction, while `dnpc` is the next dynamic instruction. For sequential instructions, their `snpc` and `dnpc` are the same; but for jump instructions, `snpc` and `dnpc` are different, and `dnpc` should point to the instruction that is the target of the jump. Obviously, we should use `s->dnpc` to update the PC, and maintain `s->dnpc` correctly during instruction execution.

* * *

The flow of an instruction execution in the NEMU has been described above, but there are a few details that have not been fully covered (e.g., the x86 instruction set decoder table), so it is up to you to try to understand these details.

#### Drive the project, not be driven by the project.

Your relationship with a program will go through 4 stages: 

1. Being driven: you don't know anything about it.
2. Understood: you have a basic understanding of the main modules and functions.
3. Fluent: you know most of the details of the entire project.
4. Mastered: You can add any functionality you want to the project.

In PA, the main way to reach the second stage is to read the handouts and the code, and the main way to reach the third stage is to complete the experiments and debug them independently. To reach the fourth stage, it is up to you: what is not good enough in the code? What is good enough? What should be done to achieve this goal?

When you graduate and go into industry or academia, you'll find that real projects are all like this.

1.  刚接触一个新项目, 不知道如何下手
2.  RTFM, RTFSC, 大致明白项目组织结构和基本的工作流程
3.  运行项目的时候发现有非预期行为(可能是配置错误或环境错误, 可能是和已有项目对接出错, 也可能是项目自身的bug), 然后调试. 在调试过程中, 对这些模块的理解会逐渐变得清晰.
4.  哪天需要你在项目中添加一个新功能, 你会发现自己其实可以胜任.

这说明了: 如果你一遇到bug就找大神帮你调试, 你失去的机会和能力会比你想象的多得多.

### [#](2.2.html#结构化程序设计) 结构化程序设计

我们刚才介绍了译码过程中的一些辅助用的函数和宏, 它们的引入都是为了实现代码的解偶, 提升可维护性. 如果指令集越复杂, 指令之间的共性特征就越多, 以x86为例:

*   对于同一条指令的不同形式, 它们的执行阶段是相同的. 例如`add_I2E`和`add_E2G`等, 它们的执行阶段都是把两个操作数相加, 把结果存入目的操作数.
*   对于不同指令的同一种形式, 它们的译码阶段是相同的. 例如`add_I2E`和`sub_I2E`等, 它们的译码阶段都是识别出一个立即数和一个`E`操作数.
*   对于同一条指令同一种形式的不同操作数宽度, 它们的译码阶段和执行阶段都是非常类似的. 例如`add_I2E_b`, `add_I2E_w`和`add_I2E_l`, 它们都是识别出一个立即数和一个`E`操作数, 然后把相加的结果存入`E`操作数.

这意味着, 如果独立实现每条指令不同形式不同操作数宽度的译码和执行过程, 将会引入大量重复的代码. 需要修改的时候, 所有相关代码都要分别修改, 遗漏了某一处就会造成bug, 工程维护的难度急速上升.

#### 来体会一下

过去有同学通过如下代码实现`isa_reg_str2val()`函数:

    if (strcmp(s, "$0") == 0)
      return cpu.gpr[0]._64;
    else if (strcmp(s, "ra") == 0)
      return cpu.gpr[1]._64;
    else if (strcmp(s, "sp") == 0)
      return cpu.gpr[2]._64;
    else if (strcmp(s, "gp") == 0)
      return cpu.gpr[3]._64;
    else if (strcmp(s, "tp") == 0)
      return cpu.gpr[4]._64;
    else if (strcmp(s, "t0") == 0)
      return cpu.gpr[5]._64;
    else if (strcmp(s, "t1") == 0)
      return cpu.gpr[6]._64;
    else if (strcmp(s, "s2") == 0)
      return cpu.gpr[7]._64;
    else if (strcmp(s, "s0") == 0)
      return cpu.gpr[8]._64;
    else if (strcmp(s, "s1") == 0)
      return cpu.gpr[9]._64;
    else if (strcmp(s, "a0") == 0)
      return cpu.gpr[10]._64;
    else if (strcmp(s, "a1") == 0)
      return cpu.gpr[11]._64;
    else if (strcmp(s, "a2") == 0)
      return cpu.gpr[12]._64;
    else if (strcmp(s, "a3") == 0)
      return cpu.gpr[13]._64;
    else if (strcmp(s, "a4") == 0)
      return cpu.gpr[14]._64;
    else if (strcmp(s, "a5") == 0)
      return cpu.gpr[15]._64;
    else if (strcmp(s, "a6") == 0)
      return cpu.gpr[16]._64;
    else if (strcmp(s, "a7") == 0)
      return cpu.gpr[17]._64;
    else if (strcmp(s, "s2") == 0)
      return cpu.gpr[18]._64;
    else if (strcmp(s, "s3") == 0)
      return cpu.gpr[19]._64;
    else if (strcmp(s, "s4") == 0)
      return cpu.gpr[20]._64;
    else if (strcmp(s, "s5") == 0)
      return cpu.gpr[21]._64;
    else if (strcmp(s, "s6") == 0)
      return cpu.gpr[22]._64;
    else if (strcmp(s, "s7") == 0)
      return cpu.gpr[23]._64;
    else if (strcmp(s, "s8") == 0)
      return cpu.gpr[24]._64;
    else if (strcmp(s, "s8") == 0)
      return cpu.gpr[25]._64;
    else if (strcmp(s, "s10") == 0)
      return cpu.gpr[26]._64;
    else if (strcmp(s, "t2") == 0)
      return cpu.gpr[27]._64;
    else if (strcmp(s, "t3") == 0)
      return cpu.gpr[28]._64;
    else if (strcmp(s, "t4") == 0)
      return cpu.gpr[29]._64;
    else if (strcmp(s, "t5") == 0)
      return cpu.gpr[30]._64;
    else if (strcmp(s, "t5") == 0)
      return cpu.gpr[31]._64;
    

你应该能想象到这位同学是如何编写上述代码的. 现在问题来了, 你能快速检查上述代码是否正确吗?

更多地, 如果你的项目中有很多这样的代码, 你还愿意仔细地读一读它们吗?

#### Copy-Paste - 一种糟糕的编程习惯

事实上, 第一版PA发布的时候, 框架代码就恰恰是引导大家独立实现每一条指令的译码和执行过程. 大家在实现指令的时候, 都是把已有的代码复制好几份, 然后进行一些微小的改动(例如把`<<`改成`>>`). 当你发现这些代码有bug的时候, 噩梦才刚刚开始. 也许花了好几天你又调出一个bug的时候, 才会想起这个bug你好像之前在哪里调过. 你也知道代码里面还有类似的bug, 但你已经分辨不出哪些代码是什么时候从哪个地方复制过来的了. 由于当年的框架代码没有足够重视编程风格, 导致学生深深地陷入调试的泥淖中, 这也算是PA的一段黑历史了.

这种糟糕的编程习惯叫Copy-Paste, 经过上面的分析, 相信你也已经领略到它的可怕了. 事实上, [周源源教授open in new window](https://cseweb.ucsd.edu/~yyzhou/)的团队在2004年就设计了一款工具CP-Miner, 来自动检测操作系统代码中由于Copy-Paste造成的bug. 这个工具还让周源源教授收获了一篇[系统方向顶级会议OSDI的论文open in new window](http://pages.cs.wisc.edu/~shanlu/paper/OSDI04-CPMiner.pdf), 这也是她当时所在学校UIUC史上的第一篇系统方向的顶级会议论文.

后来周源源教授发现, 相比于操作系统, 应用程序的源代码中Copy-Paste的现象更加普遍. 于是她们团队把CP-Miner的技术应用到应用程序的源代码中, 并创办了PatternInsight公司. 很多IT公司纷纷购买PatternInsight的产品, 并要求提供相应的定制服务, 甚至PatternInsight公司最后还被VMWare收购了.

这个故事折射出, 大公司中程序员的编程习惯也许不比你好多少, 他们也会写出Copy-Paste这种难以维护的代码. 但反过来说, 重视编码风格这些企业看中的能力, 你从现在就可以开始培养.

一种好的做法是把译码, 执行和操作数宽度的相关代码分离开来, 实现解耦, 也就是在程序设计课上提到的结构化程序设计. 在框架代码中, 实现译码和执行之间的解耦的是通过`INSTPAT`定义的模式匹配规则, 这样我们就可以分别编写译码和执行的内容, 然后来进行组合了: 这样的设计可以很容易实现执行行为相同但译码方式不同的多条指令. 对于x86, 实现操作数宽度和译码, 执行这两者之间的解耦的是`ISADecodeInfo`结构体中的`width`成员, 它们记录了操作数宽度, 译码和执行的过程中会根据它们进行不同的操作, 通过同一份译码和执行的代码实现不同操作数宽度的功能.

#### RTFSC理解指令执行的过程

这一小节的细节非常多, 你可能需要多次阅读讲义和代码才能理解每一处细节. 根据往届学长学姐的反馈, 一种有效的理解方法是通过做笔记的方式来整理这些细节. 事实上, 配合GDB食用效果更佳.

为了避免你长时间对代码的理解没有任何进展, 我们就增加一道必答题吧:

> 请整理一条指令在NEMU中的执行过程.

除了`nemu/src/device`和`nemu/src/isa/$ISA/system`之外, NEMU的其它代码你都已经有能力理解了. 因此不要觉得讲义中没有提到的文件就不需要看, 尝试尽可能地理解每一处细节吧! 在你遇到bug的时候, 这些细节就会成为帮助你调试的线索.

[#](2.2.html#运行第一个c程序) 运行第一个C程序
-------------------------------

说了这么多, 现在到了动手实践的时候了. 首先克隆一个新的子项目`am-kernels`(你可能已经在PA1中克隆这个子项目了), 里面包含了一些测试程序:

    cd ics2022
    bash init.sh am-kernels
    

你在PA2的第一个任务, 就是实现若干条指令, 使得第一个简单的C程序可以在NEMU中运行起来. 这个简单的C程序是`am-kernels/tests/cpu-tests/tests/dummy.c`, 它什么都不做就直接返回了.

#### 准备交叉编译环境

如果你选择的ISA不是x86, 你还需要准备相应的gcc和binutils, 才能正确地进行编译.

*   mips32
    *   `apt-get install g++-mips-linux-gnu binutils-mips-linux-gnu`
*   riscv32(64)
    *   `apt-get install g++-riscv64-linux-gnu binutils-riscv64-linux-gnu`

在`am-kernels/tests/cpu-tests/`目录下键入

    make ARCH=$ISA-nemu ALL=dummy run
    

编译`dummy`程序, 并启动NEMU运行它.

#### 修复riscv32编译错误

如果你选择的是riscv32, 并在编译`dummy`程序时报告了如下错误:

    /usr/riscv64-linux-gnu/include/bits/wordsize.h:28:3: error: #error "rv32i-based targets are not supported"
    

则需要使用sudo权限修改以下文件:

    --- /usr/riscv64-linux-gnu/include/bits/wordsize.h
    +++ /usr/riscv64-linux-gnu/include/bits/wordsize.h
    @@ -25,5 +25,5 @@
     #if __riscv_xlen == 64
     # define __WORDSIZE_TIME64_COMPAT32 1
     #else
    -# error "rv32i-based targets are not supported"
    +# define __WORDSIZE_TIME64_COMPAT32 0
     #endif
    

如果报告的是如下错误:

    /usr/riscv64-linux-gnu/include/gnu/stubs.h:8:11: fatal error: gnu/stubs-ilp32.h: No such file or directory
    

则需要使用sudo权限修改以下文件:

    --- /usr/riscv64-linux-gnu/include/gnu/stubs.h
    +++ /usr/riscv64-linux-gnu/include/gnu/stubs.h
    @@ -5,5 +5,5 @@
     #include <bits/wordsize.h>
    
     #if __WORDSIZE == 32 && defined __riscv_float_abi_soft
    -# include <gnu/stubs-ilp32.h>
    +//# include <gnu/stubs-ilp32.h>
     #endif
    

事实上, 并不是每一个程序都可以在NEMU中运行, `abstract-machine`子项目专门用于编译出能在NEMU中运行的程序, 我们在下一小节中会再来介绍它.

在NEMU中运行`dummy`程序, 你会发现NEMU输出以下信息(以riscv32为例):

    invalid opcode(PC = 0x80000000):
            13 04 00 00 17 91 00 00 ...
            00000413 00009117...
    There are two cases which will trigger this unexpected exception:
    1. The instruction at PC = 0x80000000 is not implemented.
    2. Something is implemented incorrectly.
    Find this PC(0x80000000) in the disassembling result to distinguish which case it is.
    
    If it is the first case, see
           _                         __  __                         _ 
          (_)                       |  \/  |                       | |
      _ __ _ ___  ___ ________   __ | \  / | __ _ _ __  _   _  __ _| |
     | '__| / __|/ __|______\ \ / / | |\/| |/ _` | '_ \| | | |/ _` | |
     | |  | \__ \ (__        \ V /  | |  | | (_| | | | | |_| | (_| | |
     |_|  |_|___/\___|        \_/   |_|  |_|\__,_|_| |_|\__,_|\__,_|_|
    
    for more details.
    
    If it is the second case, remember:
    * The machine is always right!
    * Every line of untested code is always wrong!
    

这是因为你还没有实现`0x00000413`的指令, 因此, 你需要开始在NEMU中添加指令了.

#### 为什么执行了未实现指令会出现上述报错信息

RTFSC, 理解执行未实现指令的时候, NEMU具体会怎么做.

要实现哪些指令才能让`dummy`在NEMU中运行起来呢? 答案就在其反汇编结果(`am-kernels/tests/cpu-tests/build/dummy-$ISA-nemu.txt`)中: 你只需实现那些目前还没实现的指令就可以了. 框架代码引入的模式匹配规则, 对在NEMU中实现客户指令提供了很大的便利, 为了实现一条新指令, 你只需要在`nemu/src/isa/$ISA/inst.c`中添加正确的模式匹配规则即可.

#### 交叉编译工具链

如果你选择的ISA不是x86, 在查看客户程序的二进制信息(如`objdump`, `readelf`等)时, 需要使用相应的交叉编译版本, 如`mips-linux-gnu-objdump`, `riscv64-linux-gnu-readelf`等. 特别地, 如果你选择的ISA是riscv32, 也可以使用riscv64为前缀的交叉编译工具链.

这里要再次强调, 你务必通过RTFM来查阅指令的功能, 不能想当然. 手册中给出了指令功能的完整描述(包括做什么事, 怎么做的, 有什么影响), 一定要仔细阅读其中的每一个单词, 对指令功能理解错误和遗漏都会给以后的调试带来巨大的麻烦.

#### 再提供一些x86的提示吧

*   `call`: `call`指令有很多形式, 不过在PA中只会用到其中的几种, 现在只需要实现`CALL rel32`的形式就可以了. 至于跳转地址, 框架代码里面已经有不少提示了, 也就算作是RTFSC的一个练习吧.
*   `push`: 现在只需要实现`PUSH r32`和`PUSH imm32`的形式就可以了
*   `sub`: 在实现`sub`指令之前, 你首先需实现EFLAGS寄存器. 你只需要在寄存器结构体中添加EFLAGS寄存器即可. EFLAGS是一个32位寄存器, 但在NEMU中, 我们只会用到EFLAGS中以下的5个位: `CF`, `ZF`, `SF`, `IF`, `OF`, 其它位的功能可暂不实现. 关于EFLAGS中每一位的含义, 请查阅i386手册. 实现了EFLAGS寄存器之后, 你就可以实现`sub`指令了
*   `xor`, `ret`: RTFM吧

#### 运行第一个客户程序

在NEMU中实现上文提到的指令, 具体细节请务必参考手册. 实现成功后, 在NEMU中运行客户程序`dummy`, 你将会看到`HIT GOOD TRAP`的信息. 如果你没有看到这一信息, 说明你的指令实现不正确, 你可以使用PA1中实现的简易调试器帮助你调试.

[#](2.2.html#运行更多的程序) 运行更多的程序
-----------------------------

未测试代码永远是错的, 你需要更多的测试用例来测试你的NEMU. 我们在`am-kernels/tests/cpu-tests/`目录下准备了一些简单的测试用例. 在该目录下执行

    make ARCH=$ISA-nemu ALL=xxx run
    

其中`xxx`为测试用例的名称(不包含`.c`后缀).

上述`make run`的命令最终会启动NEMU, 并运行相应的客户程序. 如果你需要使用GDB来调试NEMU运行客户程序的情况, 可以执行以下命令:

    make ARCH=$ISA-nemu ALL=xxx gdb
    

#### 实现更多的指令

你需要实现更多的指令, 以通过上述测试用例.

你可以自由选择按照什么顺序来实现指令. 经过PA1的训练之后, 你应该不会实现所有指令之后才进行测试了. 要养成尽早做测试的好习惯, 一般原则都是"实现尽可能少的指令来进行下一次的测试". 你不需要实现所有指令的所有形式, 只需要通过这些测试即可. 如果将来仍然遇到了未实现的指令, 就到时候再实现它们.

框架代码已经实现了部分指令, 但可能未编写相应的模式匹配规则. 此外, 部分函数的功能也并没有完全实现好(框架代码中已经插入了`TODO()`作为提示), 你还需要编写相应的功能.

由于`string`和`hello-str`还需要实现额外的内容才能运行(具体在后续小节介绍), 目前可以先使用其它测试用例进行测试.

#### 不要以为只需要在TODO处写代码

过去经常有同学认为, "我只需要在出现`TODO`的地方写代码就可以了, 如果一个功能在框架代码中没有相应的`TODO`, 它就是超出必做内容的范围, 我不需要实现."

在PA中, 这种想法是错误的. 如果你RTFSC, 你会发现`TODO()`只是个宏, 展开之后会调用`panic()`. 因此框架代码中的`TODO`更多地是在NEMU运行的时候给出可读性更好的结果(如xxx未实现), 而不是让NEMU触发让你畏惧的段错误.

你毕业后进入公司/课题组, 不会再有讲义具体地告诉你应该做什么, 总有一天你需要在脱离讲义的情况下完成任务. 我们希望你现在就放弃"讲义和框架代码会把我应该做的一切细节清楚地告诉我"的幻想, 为自己承担起"理解整个系统工作原理"的责任, 而不是成为框架代码的奴仆. 因此, 当你疑惑一个功能是否需要实现时, 你不应该通过框架代码中是否有`TODO`来进行判断, 而是应该根据你对代码的理解和当下的需求来做决定.

#### x86指令相关的注意事项

*   `push imm8`指令行为补充. `push imm8`指令需要对立即数进行符号扩展, 这一点在i386手册中并没有明确说明. 在[IA-32手册open in new window](http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf)中关于`push`指令有如下说明:

> If the source operand is an immediate and its size is less than the operand size, a sign-extended value is pushed on the stack.

*   字符串操作指令. 如`movsb`等, 这些指令需要用到段寄存器`DS`, `ES`以及EFLAGS寄存器中的`DF`标志. 在PA中无需实现这些寄存器, RTFM时认为这些寄存器的值恒为`0`来理解指令的语义即可.
*   `endbr32`指令. 具体见[这里](2.2.html#%E5%8E%BB%E9%99%A4endbr32%E6%8C%87%E4%BB%A4)

#### mips32的分支延迟槽

为了提升处理器的性能, mips使用了一种叫[分支延迟槽open in new window](https://en.wikipedia.org/wiki/Delay_slot)的技术. 采用这种技术之后, 程序的执行顺序会发生一些改变: 我们把紧跟在跳转指令(包括有条件和无条件)之后的静态指令称为延迟槽, 那么程序在执行完跳转指令后, 会先执行延迟槽中的指令, 再执行位于跳转目标的指令. 例如

    100: beq 200
    101: add
    102: xor
    ...
    200: sub
    201: j   102
    202: slt
    

若`beq`指令的执行结果为跳转, 则相应的动态指令流为`100 -> 101 -> 200`; 若`beq`指令的执行结果为不跳转, 则相应的动态指令流为`100 -> 101 -> 102`; 而对于`j`指令, 相应的动态指令流为`201 -> 202 -> 102`.

你一定会对这种反直觉的技术如何提升处理器性能而感到疑惑. 不过这需要你先了解一些微结构的知识, 例如[处理器流水线open in new window](http://en.wikipedia.org/wiki/Classic_RISC_pipeline), 但这已经超出了ICS的课程范围了, 所以我们也不详细解释了, 感兴趣的话可以STFW.

但我们可以知道, 延迟槽技术需要软硬件协同才能正确工作: mips手册中描述了这一约定, 处理器设计者按照这一约定设计处理器, 而编译器开发者则会让编译器负责在延迟槽中放置一条有意义的指令, 使得无论是否跳转, 按照这一约定的执行顺序都能得到正确的执行结果.

如果你是编译器开发者, 你将会如何寻找合适的指令放到延迟槽中呢?

#### mips32-NEMU的分支延迟槽

既然mips有这样的约定, 而编译器也已经遵循这一约定, 那么对于mips32编译器生成的程序, 我们也应该遵循这一约定来解释其语义. 这意味着, mips32-NEMU作为一个模拟的mips32 CPU, 也需要实现分支延迟槽技术, 才能正确地支撑mips32程序的运行.

事实上, gcc为mips32程序的生成提供了一个`-fno-delayed-branch`的编译选项, 让mips32程序中的延迟槽中都放置`nop`指令. 这样以后, 执行跳转指令之后, 接下来就可以直接执行跳转目标的指令了, 因为延迟槽中都是`nop`指令, 就算不执行它, 也不会影响程序的正确性.

我们已经在编译mips32程序的命令中添加了这一编译选项, 于是我们在实现mips32-NEMU的时候就可以进行简化, 无需实现分支延迟槽了.

对PA来说, 去掉延迟槽还有其它的好处, 我们会在后续内容中进行讨论.

#### 指令名对照

AT&T格式反汇编结果中的少量指令, 与手册中列出的指令名称不符, 如x86的`cltd`, mips32和riscv32则有不少伪指令(pseudo instruction). 除了STFW之外, 你有办法在手册中找到对应的指令吗? 如果有的话, 为什么这个办法是有效的呢?

#### 温馨提示

PA2阶段1到此结束.

[不停计算的机器](2.1.html) [程序, 运行时环境与AM](2.3.html)