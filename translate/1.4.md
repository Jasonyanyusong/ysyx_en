[#](#Infrastructure-Simple-Debugger) Infrastructure: Simple Debugger
============================

#### Infrastructure - Improving Efficiency in Project Development

In PA, infrastructure refers to the tools and instruments that support the development of a project. In principle, infrastructure is not part of textbook knowledge, but as a project of a certain size, the quality of the infrastructure can affect the progress of the project, and even determine the success or failure of the project, which you can not experience in the programming class.

In fact, you've already experienced what infrastructure can do for you. Our framework code already provides a Makefile for one-click compilation of NEMU. Suppose we don't provide one-click compilation, and you have to manually type in the `gcc` command to compile the source files: Suppose it takes you 10 seconds to manually type in a `gcc` command (you have to type in a lot of compilation options, and 10 seconds is very fast), and there are 30 source files under the NEMU project, how much time would you need to spend in order to compile the NEMU executable? In order to compile the NEMU executable, how much time do you need to spend? However, you also need to develop NEMU with a lot of recompiling, let's say you need to compile NEMU 500 times to complete the PA, with in a semester, how much time you just spend on typing compilation commands?

Some projects take longer to build even with tools. For example, the `vivado`/`quartus` IDE can take anywhere from half an hour to an hour to generate a bit stream, which means that after you have written the code, you may have to wait up to an hour before you can verify that your code is correct. This is because the process is not as simple as compiling a program, and there are many algorithmic NPC issues to deal with. In order to produce a decent bit stream, the hardware development tools cost more than `gcc` to solve these NPC problems. This is where infrastructure becomes even more important, and having tools that can help you verify multiple aspects at once can save you countless "hours".

Google's internal development team places a high value on infrastructure, calling tools that benefit one project an Adder, and tools that benefit multiple projects a Multiplier. As the name implies, these tools can multiply the efficiency of a project's development. In academia, the goal of many research efforts is also to improve development efficiency, such as automated bug detection and fixing, automated verification, and easy-to-develop programming models. In PA, the infrastructure also manifests itself in different ways, and we will discuss other aspects in the future.

You will certainly be involved in larger projects than PA in the future, and the question of how to improve the efficiency of project development is also an important one. Hopefully, in the course of completing PA, you will gain a new understanding of infrastructure: where there's code, there's infrastructure. As you gain knowledge, you may be able to contribute to these uncharted territories and make a difference to developers all over the world.

#### True Stories

In yzh's group, there was an incident where the quality of the research was not satisfactory before the submission deadline due to poor infrastructure.

The work required running different tests to verify the results, and it took about 24 hours to run all the tests on two 4-core, 8-thread PCs. Each time a change was made to the design, all the tests had to be re-run, so it took 24 hours to get the results after changing one line of code. In fact, three months before the submission deadline, we learned that a 112-core server was available. Deploying the test environment on this server was expected to reduce the total test time to 1/5 of the original time (1/5 is a comprehensive figure given that multi-core servers has half of the CPU frequency compares to PCs, and the architecture is two generations behind).

But the student leading the project didn't realize the importance of the infrastructure: he was always testing on a PC. In fact, reducing the total testing time to 1/5th of the original time meant that the chances of improving the design were five times greater. As a result, by the deadline, the design was still being revised, the tests were still being run over and over again, and he had no choice but to submit the paper with a version of the design that needed to be improved.

The Simple Debugger (sdb) is a very important infrastructure in NEMU. We know that NEMU is a program that is used to execute other client programs, which means that NEMU has all the information about the execution of the client program at all times. However, this information is not easily accessible to outside debuggers (e.g., GDB). For example, when debugging NEMU through GDB, you will have a hard time setting breakpoints in a client program running in NEMU, but for NEMU, this is a less difficult task.

In order to improve the efficiency of debugging, but also as an exercise to familiarize with the framework code, we need to implement a simple debugger with the following functions in monitor (the relevant part of the code in the `nemu/src/monitor/sdb/` directory), if you are not clear about the format and function of the commands, please refer to the following table:

Command

Format

Example

Explanation

Help(1)

`help`

`help`

Prints help information for the command

Continue running(1)

`c`

`c`

Resume running the suspended program

Quit(1)

`q`

`q`

Exit NEMU

Single-step execution

`si [N]`

`si 10`

Lets the program pause after executing `N` instructions using single step execution
When `N` is not given, the default is `1`.

Print program status

`info SUBCMD`

`info r`  
`info w`

Print register status  
Print watchpoint information

Scan memory (2)

`x N EXPR`

`x 10 $esp`

Finds the value of the expression `EXPR`, uses the result as the starting memory  
address, and outputs consecutive `N` 4 bytes in hexadecimal.

Expression evaluation

`p EXPR`

`p $eax + 1`

Find the value of the expression `EXPR`, for `EXPR` supported operations
See the chapter [Expression evaluation in debugging](/docs/ics-pa/1.6.html).

Set watchpoint

`w EXPR`

`w *0x2000`

Suspend program execution when the value of expression `EXPR` changes.

Deleting a watchpoint

`d N`

`d 2`

Deletes the watchpoint with ID `N`.

Remarks.

* (1) The command has been implemented already.
* (2) Compared to GDB, we have simplified it here by changing the format of the command.

#### Bugs that will find their way to you one day

You will need to use these features in future PAs to help you debug NEMU. If your implementation is faulty, you may end up with the following scenario: you implement a new feature, test it, scan a section of memory, and find that the output is not what you expected. You think there's something wrong with the new feature you just implemented, so you debug it. After days and nights of debugging, you realize with tears in your eyes that the memory scanning function is buggy!

If you want to avoid this kind of misery, you need to fully test a feature after you implement it. Over time, the cost of discovering the same bug becomes more and more expensive.

### [#](#解析命令) 解析命令

为了让简易调试器易于使用, NEMU通过`readline`库与用户交互, 使用`readline()`函数从键盘上读入命令. 与`gets()`相比, `readline()`提供了"行编辑"的功能, 最常用的功能就是通过上, 下方向键翻阅历史记录. 事实上, shell程序就是通过`readline()`读入命令的. 关于`readline()`的功能和返回值等信息, 请查阅

    man readline
    

从键盘上读入命令后, NEMU需要解析该命令, 然后执行相关的操作. 解析命令的目的是识别命令中的参数, 例如在`si 10`的命令中识别出`si`和`10`, 从而得知这是一条单步执行10条指令的命令. 解析命令的工作是通过一系列的字符串处理函数来完成的, 例如框架代码中的`strtok()`. `strtok()`是C语言中的标准库函数, 如果你从来没有使用过`strtok()`, 并且打算继续使用框架代码中的`strtok()`来进行命令的解析, 请务必查阅

    man strtok
    

另外, `cmd_help()`函数中也给出了使用`strtok()`的例子. 事实上, 字符串处理函数有很多, 键入以下内容:

    man 3 str<TAB><TAB>
    

其中`<TAB>`代表键盘上的TAB键. 你会看到很多以str开头的函数, 其中有你应该很熟悉的`strlen()`, `strcpy()`等函数. 你最好都先看看这些字符串处理函数的manual page, 了解一下它们的功能, 因为你很可能会用到其中的某些函数来帮助你解析命令. 当然你也可以编写你自己的字符串处理函数来解析命令.

#### 如何测试字符串处理函数?

你可能会抑制不住编码的冲动: 与其RTFM, 还不如自己写. 如果真是这样, 你可以考虑一下, 你会如何测试自己编写的字符串处理函数?

如果你愿意RTFM, 也不妨思考一下这个问题, 因为你会在PA2中遇到类似的问题.

另外一个值得推荐的字符串处理函数是`sscanf()`, 它的功能和`scanf()`很类似, 不同的是`sscanf()`可以从字符串中读入格式化的内容, 使用它有时候可以很方便地实现字符串的解析. 如果你从来没有使用过它们, RTFM, 或者STFW.

### [#](#单步执行) 单步执行

单步执行的功能十分简单, 而且框架代码中已经给出了模拟CPU执行方式的函数, 你只要使用相应的参数去调用它就可以了. 如果你仍然不知道要怎么做, RTFSC.

### [#](#打印寄存器) 打印寄存器

打印寄存器就更简单了. 不过既然寄存器的结构是ISA相关的, 我们希望能为简易调试器屏蔽ISA的差异. 框架代码已经为大家准备了如下的API:

    // nemu/src/isa/$ISA/reg.c
    void isa_reg_display(void);
    

执行`info r`之后, 就调用`isa_reg_display()`, 在里面直接通过`printf()`输出所有寄存器的值即可. 如果你从来没有使用过`printf()`, 请RTFM或者STFW. 如果你不知道要输出什么, 你可以参考GDB中的输出.

### [#](#扫描内存) 扫描内存

扫描内存的实现也不难, 对命令进行解析之后, 先求出表达式的值. 但你还没有实现表达式求值的功能, 现在可以先实现一个简单的版本: 规定表达式`EXPR`中只能是一个十六进制数, 例如

    x 10 0x80000000
    

这样的简化可以让你暂时不必纠缠于表达式求值的细节. 解析出待扫描内存的起始地址之后, 就可以使用循环将指定长度的内存数据通过十六进制打印出来. 如果你不知道要怎么输出, 同样的, 你可以参考GDB中的输出. 问题是, 我们要如何访问客户计算机的内存数据呢? (答案早就说了喂)

实现了扫描内存的功能之后, 你可以打印`0x80000000`或者`0x100000`附近的内存, 你应该会看到程序的代码, 和内置客户程序的内容进行对比, 检查你的实现是否正确.

#### 实现单步执行, 打印寄存器, 扫描内存

熟悉了NEMU的框架之后, 这些功能实现起来都很简单, 同时我们对输出的格式不作硬性规定, 就当做是熟悉GNU/Linux编程的一次练习吧.

NEMU默认会把单步执行的指令打印出来(这里面埋了一些坑, 你需要RTFSC看看指令是在哪里被打印的), 这样你就可以验证单步执行的效果了.

不知道如何下手? 嗯, 看来你需要再阅读一遍[RTFSC小节](/docs/ics-pa/1.3.html)的内容了. 如果你已经忘记了某些注意事项, 重新去阅读一遍也是应该的.

#### 我怕代码写错了啊, 怎么办?

2014年图灵奖得主[Michael Stonebrakeropen in new window](https://en.wikipedia.org/wiki/Michael_Stonebraker)在一次访谈中提到, 他当时花了5年时间开发了世界上第一个关系数据库系统Ingres, 其中90%的时间用于将它运行起来. 也就是说, 在开发过程中, 有90%的时间系统都是运行不起来的, 是有bug的, 需要调试.

所以, 接受现实吧: 代码出错是很正常的, 你需要从当年程序设计实验里感受到的那种"代码可以一次编译通过成功运行"的幻觉中清醒过来. 重要的是, 我们需要使用正确的方法和工具来帮助我们测试和调试, 最终让程序运行起来. 一个例子是版本控制工具`git`, 它可以跟踪代码的变化, 从而发现bug是何时引入的, 而且能够在必要的时候回退到上一个程序可以运行的版本.

总之, 只有掌握正确的方法和工具, 才能真正驱散心中对bug的恐惧.

#### 温馨提示

PA1阶段1到此结束.

[RTFSC](/docs/ics-pa/1.3.html) [表达式求值](/docs/ics-pa/1.5.html)
