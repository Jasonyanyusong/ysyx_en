<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.49">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" type="image/png" href="../../res/favicon.ico"><link rel="stylesheet" href="../res/fa/all.min.css"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff"><meta rel="manifest" href="/site.webmanifest"><title>多道程序 | 官方文档</title><meta name="description" content="">
    <link rel="modulepreload" href="../assets/app.4a525931.js"><link rel="modulepreload" href="https://ysyx.oscc.cc/docs/assets/4.1.html.7555d79b.js"><link rel="modulepreload" href="https://ysyx.oscc.cc/docs/assets/Context-switch.2f55ddae.js"><link rel="modulepreload" href="https://ysyx.oscc.cc/docs/assets/4.1.html.d6100612.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/index.html.a7266140.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/index.html.232934df.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/20220828-1st-tech-forum.html.0352288d.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/20230825-2nd-tech-forum.html.d1b9e033.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.1.html.b59807d6.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.2.html.8bc8b9da.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.3.html.837fafd2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.4.html.4bffb007.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.5.html.ef8d5ad6.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.6.html.6f0bd7f1.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.1.html.f0ea7137.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.2.html.1a53c337.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.3.html.caf2a3c8.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.4.html.4cbf5a60.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.5.html.df79a509.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.6.html.86cafaf6.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.7.html.8eeba125.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.1.html.e75fc45a.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.2.html.d6b41a35.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.3.html.03919a0b.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.4.html.c5c52d8f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.5.html.5d21687f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.1.html.4a79147b.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.2.html.d9011582.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.3.html.bf2039cd.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.4.html.40ffb325.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.5.html.b892d672.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.2.html.f7ed61dd.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.3.html.ecdf42db.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.4.html.1dbb0913.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.5.html.4f17311c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/5.1.html.763316a2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/5.2.html.a59ea17f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/5.3.html.76c43eb5.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/FAQ.html.63b12bf4.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA0.html.f0313a46.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA1.html.711b0eac.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA2.html.5de5ea0c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA3.html.742ae6ba.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA4.html.4c56f3c8.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA5.html.2e845c96.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/index.html.f63a8f2b.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/SUMMARY.html.ec5ea9f0.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/blank.html.8840013e.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/changelog.html.81f04b8d.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/exec.html.6ad93be9.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/feedback.html.e27071f8.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/git.html.1a915150.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/i386-intro.html.bdcbf94c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/install.html.8fcdb015.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/linux.html.282ef355.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/man.html.6e006172.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/nemu-isa-api.html.990fd076.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/why.html.7ff158c5.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.1.html.0d459461.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.2.html.2bb2f37d.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.3.html.f3366680.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.4.html.3752ac62.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.5.html.689273e3.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.6.html.8b2df824.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.1.html.0504651a.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.2.html.fb1d8b3c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.3.html.529fb578.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.4.html.9e5579fc.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.5.html.baab6d8e.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.6.html.2f272d90.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.7.html.4bb1ac68.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.1.html.19f46ba1.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.2.html.2df57027.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.3.html.7fd96b44.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.4.html.de4f4be8.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.5.html.c00bb579.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.1.html.e031a19f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.2.html.3b0d611d.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.3.html.39ad3899.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.4.html.a95da085.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.5.html.8ca71b81.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.1.html.9d707f17.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.2.html.d99be7c2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.3.html.ad2b916c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.4.html.fe3dab0c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.5.html.29b6103a.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/5.1.html.8311ab5c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/5.2.html.f9c0e541.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/5.3.html.05e60dbb.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/FAQ.html.5728bbbc.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA0.html.677b1d1f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA1.html.c29ccb12.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA2.html.0822ebd7.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA3.html.aaa28f3f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA4.html.5ee6b43b.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA5.html.63c57ad2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/index.html.fe3ed219.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/SUMMARY.html.cc6af0af.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/blank.html.01771de7.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/changelog.html.6878181f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/exec.html.0a4cc38f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/feedback.html.c6b019d6.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/git.html.4c8ac010.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/i386-intro.html.09e89e76.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/install.html.f8cfc8fd.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/linux.html.2eccd12c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/man.html.89bba41a.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/nemu-isa-api.html.ee2ea84e.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/why.html.6c68e2a6.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.1.html.5c976ac1.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.2.html.66db2f3f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.3.html.4aac06d9.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.4.html.e05b3fae.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.5.html.2eb42db1.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.6.html.830952b9.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.7.html.154c6975.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.8.html.cd9745bd.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.9.html.a68a9bf2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/advanced.html.633848dd.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.1.html.d1209dc4.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.10.html.af72b9f4.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.2.html.5e6f403b.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.3.html.a86ca13a.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.4.html.c8ea1de9.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.5.html.c486e237.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.6.html.17ca572d.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.7.html.7080b768.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.8.html.7502ac87.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.9.html.bedcb78f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/baseline.html.3e2909ae.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.1.html.73f0d75e.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.2.html.899db208.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.3.html.25cabbbb.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.4.html.2cbf3a34.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.5.html.a6bbf717.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.6.html.5ec49f77.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.7.html.6408936c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/prestudy.html.a9250176.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.1.html.4463740c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.2.html.d1e36fd2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.3.html.ae57c7b7.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.4.html.6c63dbcc.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.5.html.ae2cdc09.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.6.html.d86fb91e.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/specialist.html.69d2f484.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/index.html.7db9802e.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/schedule-origin.html.6f8a7a8c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/schedule.html.2b0c5ddc.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.1.html.277e5588.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.2.html.77ed5027.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.3.html.c002cd7b.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.4.html.af2e37c7.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.5.html.ce15f76b.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.6.html.04203cf4.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.7.html.3f64070f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.8.html.f2613449.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.9.html.6b985c58.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/advanced.html.65e379b5.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/index.html.2995e200.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.1.html.583540ad.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.2.html.c221742a.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.3.html.f4c8a5e5.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.4.html.a76cfae7.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.5.html.57aaf57c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.6.html.4fd2530f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.7.html.8a297aa0.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/prestudy.html.867e5d4c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.1.html.e2efd6a7.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.2.html.aefd1e74.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.3.html.46b068a0.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.4.html.f550e424.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.5.html.a68ea659.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/baseline.html.619d3b2a.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/soc.1.html.afb02b35.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/soc.2.html.f7df462f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/soc.3.html.e14cfa2a.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/soc.4.html.ef83adf5.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/ask.html.7c717162.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.1.html.4b1c8ec7.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.2.html.2fa39d0f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.3.html.409b7b55.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.4.html.42646124.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.5.html.3a73f236.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.6.html.8e8c660b.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/specialist.html.3efa6e29.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/faq.html.70d41486.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/student.html.8ffc0d97.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/notice.html.12c7f762.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/meaning-goal.html.86dddc36.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/overview.html.fab21fcd.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/pass.html.9faccc41.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/training-concept.html.07c7d25c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/assistant.html.ab9ff4a0.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/notice.html.497a2ada.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/support.html.a0e77657.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/404.html.ce538133.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/index.html.cf814034.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/index.html.7a821f23.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/20220828-1st-tech-forum.html.686d7136.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/20230825-2nd-tech-forum.html.f5771670.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.1.html.e8dafc44.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.2.html.c1a3a5c8.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.3.html.d39c2034.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.4.html.4bc666d2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.5.html.dba9e3d2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.6.html.f6ff707e.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.1.html.c21b4394.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.2.html.a1a8df20.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.3.html.0bf7a167.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.4.html.ae74c2b2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.5.html.f40c8ae0.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.6.html.17832a39.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.7.html.a8c86a81.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.1.html.6d44643a.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.2.html.443e26a6.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.3.html.e1e938ec.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.4.html.1f907af1.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.5.html.2d383856.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.1.html.cbf5cdab.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.2.html.27c85899.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.3.html.60c4b9fb.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.4.html.bda34a22.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.5.html.4124a18f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.2.html.c4a6353d.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.3.html.7f7aa959.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.4.html.3c240e28.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.5.html.df1ba6e4.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/5.1.html.6c462bbc.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/5.2.html.d14de6d8.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/5.3.html.8b52ccd1.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/FAQ.html.e6a44f5f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA0.html.2ef80bf5.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA1.html.891782b4.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA2.html.9658a1f2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA3.html.d1b8800a.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA4.html.950d2e14.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA5.html.803dd116.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/index.html.511193b6.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/SUMMARY.html.b1b9fd0f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/blank.html.281c2647.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/changelog.html.df9df882.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/exec.html.3d818a5c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/feedback.html.bdf42a97.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/git.html.6dee9910.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/i386-intro.html.cc3d6f08.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/install.html.ca20ca3b.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/linux.html.982cb2be.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/man.html.78c8d359.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/nemu-isa-api.html.39ea2347.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/why.html.0f36cdb7.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.1.html.352b1ee5.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.2.html.f097f5f7.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.3.html.6163e6cd.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.4.html.a6ae9139.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.5.html.610f7dc5.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.6.html.d728a707.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.1.html.c5ec55ed.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.2.html.cfa4dabf.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.3.html.68177e2a.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.4.html.2dda1d06.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.5.html.a5a0e665.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.6.html.378e72eb.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.7.html.4b625448.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.1.html.806caf93.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.2.html.86a4b0f2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.3.html.32aa5d26.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.4.html.f35b7445.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.5.html.717e4c76.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.1.html.4fa6f565.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.2.html.52e6ba49.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.3.html.e20d38cc.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.4.html.a96a451c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.5.html.fb745285.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.1.html.a280e6c2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.2.html.fff6883e.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.3.html.ff9fbed3.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.4.html.ff8add10.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/4.5.html.55ea5ab1.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/5.1.html.41b33646.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/5.2.html.b52ba57d.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/5.3.html.c9dbb4ee.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/FAQ.html.fd208f3b.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA0.html.1a552340.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA1.html.c7feba93.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA2.html.bc1f14af.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA3.html.41b913b0.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA4.html.5795ee2c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/PA5.html.b1b4ef4f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/index.html.2f4f0270.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/SUMMARY.html.641d7708.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/blank.html.1aa151fe.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/changelog.html.af92abe2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/exec.html.3d563957.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/feedback.html.0982b9a7.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/git.html.894286f9.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/i386-intro.html.5f6ebfe8.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/install.html.6820135d.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/linux.html.92f11c92.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/man.html.0b859cb2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/nemu-isa-api.html.65a8ec7b.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/why.html.dcd9327f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.1.html.cec3e29d.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.2.html.a08b9c2f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.3.html.2e08d202.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.4.html.6cfe35a7.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.5.html.107ccf2f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.6.html.358e830c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.7.html.99f5d2da.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.8.html.5f125032.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.9.html.d3bbba57.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/advanced.html.0e654d5c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.1.html.b0bca01c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.10.html.e5e078aa.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.2.html.ba4ab312.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.3.html.546f9c64.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.4.html.fbcf467d.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.5.html.2acafdfa.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.6.html.d966fecb.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.7.html.14b3bf1d.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.8.html.de83bd00.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.9.html.1a542954.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/baseline.html.92dfeabf.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.1.html.6aeaccaf.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.2.html.c368f429.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.3.html.dfdd0db6.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.4.html.290587b2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.5.html.f00f6f04.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.6.html.a074c18d.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.7.html.46e71345.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/prestudy.html.afef3155.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.1.html.cdc53db6.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.2.html.23ebb3dd.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.3.html.85c3bd36.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.4.html.b88be577.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.5.html.ff515b78.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.6.html.b41b68ca.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/specialist.html.26bdf948.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/index.html.878255da.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/schedule-origin.html.eacc721e.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/schedule.html.75d22e8d.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.1.html.4a82c235.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.2.html.2efb3275.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.3.html.47c8c0e8.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.4.html.55da5ce3.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.5.html.7c06d8b5.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.6.html.ed6d8049.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.7.html.c62fc84b.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.8.html.90b91f6a.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/2.9.html.1a5b8c85.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/advanced.html.7f4bb1ce.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/index.html.26370994.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.1.html.126c2f34.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.2.html.9e240aae.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.3.html.11cc66de.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.4.html.38669bc0.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.5.html.db19d255.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.6.html.7fa636ec.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/0.7.html.1d859400.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/prestudy.html.4ec5d8de.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.1.html.3df341b2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.2.html.d6a68a54.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.3.html.4e944541.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.4.html.e3d83b6a.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/1.5.html.f2a503c2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/baseline.html.1963ceb8.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/soc.1.html.1ecb1941.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/soc.2.html.d102f9fc.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/soc.3.html.00e9d91f.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/soc.4.html.8305527d.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/ask.html.b699966b.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.1.html.1c7a13e2.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.2.html.fdca3095.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.3.html.a7f3f20d.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.4.html.600be615.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.5.html.5830d684.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/3.6.html.ae89b90d.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/specialist.html.9aabba01.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/faq.html.caad27ac.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/student.html.7e730436.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/notice.html.17a148ae.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/meaning-goal.html.a9225751.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/overview.html.6004fd9b.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/pass.html.8d48939e.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/training-concept.html.01972c26.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/assistant.html.44c3fbb5.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/notice.html.2bcb6cfd.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/support.html.3242a66b.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/404.html.40b8a745.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/404.4e6b58b0.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/Layout.c0ed3a05.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/Container.3cafa256.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/Responsive.dde7be9c.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/Badge.ce404839.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/TriStateLink.74a9f928.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/Button.0f341231.js"><link rel="prefetch" href="https://ysyx.oscc.cc/docs/assets/MjxContainer.f281b7b6.js">
    <link rel="stylesheet" href="../assets/style.43f1000b.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><div><span class="can-hide site-name">第六期</span><img class="logo" src="../res/logo.png" alt="官方文档" style="margin-right:0px;position:relative;top:1px;"><span class="can-hide site-name">学习讲义</span></div></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="课程主页"><span class="title">课程主页</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="课程主页"><span class="title">课程主页</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="https://ysyx.oscc.cc/docs/" class="" aria-label="第六期"><!--[--><!--]--> 第六期 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="https://ysyx.oscc.cc/docs/2205" class="" aria-label="第五期"><!--[--><!--]--> 第五期 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="学习讲义"><span class="title">学习讲义</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="学习讲义"><span class="title">学习讲义</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><a href="https://ysyx.oscc.cc/docs/2306/prestudy/prestudy" class="" aria-label="预学习阶段"><!--[--><!--]--> 预学习阶段 <!--[--><!--]--></a></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/prestudy/0.1.html" class="" aria-label="如何科学地提问"><!--[--><!--]--> 如何科学地提问 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/prestudy/0.2.html" class="" aria-label="Linux系统安装和基本使用"><!--[--><!--]--> Linux系统安装和基本使用 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/prestudy/0.3.html" class="" aria-label="复习C语言"><!--[--><!--]--> 复习C语言 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/prestudy/0.4.html" class="" aria-label="搭建verilator仿真环境"><!--[--><!--]--> 搭建verilator仿真环境 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/prestudy/0.5.html" class="" aria-label="数字电路基础实验"><!--[--><!--]--> 数字电路基础实验 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/prestudy/0.6.html" class="" aria-label="完成PA1"><!--[--><!--]--> 完成PA1 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/prestudy/0.7.html" class="" aria-label="提交入学答辩申请"><!--[--><!--]--> 提交入学答辩申请 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><a href="https://ysyx.oscc.cc/docs/2306/baseline/baseline" class="" aria-label="基础阶段"><!--[--><!--]--> 基础阶段 <!--[--><!--]--></a></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.1.html" class="" aria-label="支持RV32IM的NEMU"><!--[--><!--]--> 支持RV32IM的NEMU <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.2.html" class="" aria-label="用RTL实现最简单的处理器"><!--[--><!--]--> 用RTL实现最简单的处理器 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.3.html" class="" aria-label="运行时环境和基础设施"><!--[--><!--]--> 运行时环境和基础设施 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.4.html" class="" aria-label="支持RV32E的单周期NPC"><!--[--><!--]--> 支持RV32E的单周期NPC <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.5.html" class="" aria-label="设备和输入输出"><!--[--><!--]--> 设备和输入输出 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.6.html" class="" aria-label="简单的异常处理机制"><!--[--><!--]--> 简单的异常处理机制 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.7.html" class="" aria-label="总线"><!--[--><!--]--> 总线 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.8.html" class="" aria-label="SoC计算机系统"><!--[--><!--]--> SoC计算机系统 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.9.html" class="" aria-label="性能和简单缓存"><!--[--><!--]--> 性能和简单缓存 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.10.html" class="" aria-label="流水线处理器"><!--[--><!--]--> 流水线处理器 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="其它资料"><span class="title">其它资料</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="其它资料"><span class="title">其它资料</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><a href="https://ysyx.oscc.cc/docs/ics-pa" class="router-link-active" aria-label="南京大学&quot;计算机系统基础&quot;实验(PA)"><!--[--><!--]--> 南京大学&quot;计算机系统基础&quot;实验(PA) <!--[--><!--]--></a></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="PA0.html" class="" aria-label="PA0 - 世界诞生的前夜: 开发环境配置"><!--[--><!--]--> PA0 - 世界诞生的前夜: 开发环境配置 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="PA1.html" class="" aria-label="PA1 - 开天辟地的篇章: 最简单的计算机"><!--[--><!--]--> PA1 - 开天辟地的篇章: 最简单的计算机 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="PA2.html" class="" aria-label="PA2 - 简单复杂的机器: 冯诺依曼计算机系统"><!--[--><!--]--> PA2 - 简单复杂的机器: 冯诺依曼计算机系统 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="PA3.html" class="" aria-label="PA3 - 穿越时空的旅程: 批处理系统"><!--[--><!--]--> PA3 - 穿越时空的旅程: 批处理系统 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="PA4.html" class="" aria-label="PA4 - 虚实交错的魔法: 分时多任务"><!--[--><!--]--> PA4 - 虚实交错的魔法: 分时多任务 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><div style="height:100%;display:flex;margin:0 0 0 1em;align-items:center;"><!----></div><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="课程主页"><span class="title">课程主页</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="课程主页"><span class="title">课程主页</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="https://ysyx.oscc.cc/docs/" class="" aria-label="第六期"><!--[--><!--]--> 第六期 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="https://ysyx.oscc.cc/docs/2205" class="" aria-label="第五期"><!--[--><!--]--> 第五期 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="学习讲义"><span class="title">学习讲义</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="学习讲义"><span class="title">学习讲义</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><a href="https://ysyx.oscc.cc/docs/2306/prestudy/prestudy" class="" aria-label="预学习阶段"><!--[--><!--]--> 预学习阶段 <!--[--><!--]--></a></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/prestudy/0.1.html" class="" aria-label="如何科学地提问"><!--[--><!--]--> 如何科学地提问 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/prestudy/0.2.html" class="" aria-label="Linux系统安装和基本使用"><!--[--><!--]--> Linux系统安装和基本使用 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/prestudy/0.3.html" class="" aria-label="复习C语言"><!--[--><!--]--> 复习C语言 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/prestudy/0.4.html" class="" aria-label="搭建verilator仿真环境"><!--[--><!--]--> 搭建verilator仿真环境 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/prestudy/0.5.html" class="" aria-label="数字电路基础实验"><!--[--><!--]--> 数字电路基础实验 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/prestudy/0.6.html" class="" aria-label="完成PA1"><!--[--><!--]--> 完成PA1 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/prestudy/0.7.html" class="" aria-label="提交入学答辩申请"><!--[--><!--]--> 提交入学答辩申请 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><a href="https://ysyx.oscc.cc/docs/2306/baseline/baseline" class="" aria-label="基础阶段"><!--[--><!--]--> 基础阶段 <!--[--><!--]--></a></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.1.html" class="" aria-label="支持RV32IM的NEMU"><!--[--><!--]--> 支持RV32IM的NEMU <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.2.html" class="" aria-label="用RTL实现最简单的处理器"><!--[--><!--]--> 用RTL实现最简单的处理器 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.3.html" class="" aria-label="运行时环境和基础设施"><!--[--><!--]--> 运行时环境和基础设施 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.4.html" class="" aria-label="支持RV32E的单周期NPC"><!--[--><!--]--> 支持RV32E的单周期NPC <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.5.html" class="" aria-label="设备和输入输出"><!--[--><!--]--> 设备和输入输出 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.6.html" class="" aria-label="简单的异常处理机制"><!--[--><!--]--> 简单的异常处理机制 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.7.html" class="" aria-label="总线"><!--[--><!--]--> 总线 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.8.html" class="" aria-label="SoC计算机系统"><!--[--><!--]--> SoC计算机系统 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.9.html" class="" aria-label="性能和简单缓存"><!--[--><!--]--> 性能和简单缓存 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="https://ysyx.oscc.cc/docs/2306/baseline/1.10.html" class="" aria-label="流水线处理器"><!--[--><!--]--> 流水线处理器 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="其它资料"><span class="title">其它资料</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="其它资料"><span class="title">其它资料</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><a href="https://ysyx.oscc.cc/docs/ics-pa" class="router-link-active" aria-label="南京大学&quot;计算机系统基础&quot;实验(PA)"><!--[--><!--]--> 南京大学&quot;计算机系统基础&quot;实验(PA) <!--[--><!--]--></a></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="PA0.html" class="" aria-label="PA0 - 世界诞生的前夜: 开发环境配置"><!--[--><!--]--> PA0 - 世界诞生的前夜: 开发环境配置 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="PA1.html" class="" aria-label="PA1 - 开天辟地的篇章: 最简单的计算机"><!--[--><!--]--> PA1 - 开天辟地的篇章: 最简单的计算机 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="PA2.html" class="" aria-label="PA2 - 简单复杂的机器: 冯诺依曼计算机系统"><!--[--><!--]--> PA2 - 简单复杂的机器: 冯诺依曼计算机系统 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="PA3.html" class="" aria-label="PA3 - 穿越时空的旅程: 批处理系统"><!--[--><!--]--> PA3 - 穿越时空的旅程: 批处理系统 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="PA4.html" class="" aria-label="PA4 - 虚实交错的魔法: 分时多任务"><!--[--><!--]--> PA4 - 虚实交错的魔法: 分时多任务 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="index.html" class="router-link-active sidebar-item sidebar-heading" aria-label="南京大学 &quot;计算机系统基础&quot; 实验"><!--[--><!--]--> 南京大学 &quot;计算机系统基础&quot; 实验 <!--[--><!--]--></a><!----></li><li><a href="PA0" class="sidebar-item sidebar-heading" aria-label="PA0 - 世界诞生的前夜: 开发环境配置"><!--[--><!--]--> PA0 - 世界诞生的前夜: 开发环境配置 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="0.1.html" class="sidebar-item" aria-label="Preparation"><!--[--><!--]--> Preparation <!--[--><!--]--></a><!----></li><li><a href="0.2.html" class="sidebar-item" aria-label="First Exploration with GNU/Linux"><!--[--><!--]--> First Exploration with GNU/Linux <!--[--><!--]--></a><!----></li><li><a href="0.3.html" class="sidebar-item" aria-label="Installing Tools"><!--[--><!--]--> Installing Tools <!--[--><!--]--></a><!----></li><li><a href="0.4.html" class="sidebar-item" aria-label="Configuring vim"><!--[--><!--]--> Configuring vim <!--[--><!--]--></a><!----></li><li><a href="0.5.html" class="sidebar-item" aria-label="More Exploration"><!--[--><!--]--> More Exploration <!--[--><!--]--></a><!----></li><li><a href="0.6.html" class="sidebar-item" aria-label="Getting Source Code for PAs"><!--[--><!--]--> Getting Source Code for PAs <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="PA1" class="sidebar-item sidebar-heading" aria-label="PA1 - 开天辟地的篇章: 最简单的计算机"><!--[--><!--]--> PA1 - 开天辟地的篇章: 最简单的计算机 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="1.1.html" class="sidebar-item" aria-label="在开始愉快的PA之旅之前"><!--[--><!--]--> 在开始愉快的PA之旅之前 <!--[--><!--]--></a><!----></li><li><a href="1.2.html" class="sidebar-item" aria-label="开天辟地的篇章"><!--[--><!--]--> 开天辟地的篇章 <!--[--><!--]--></a><!----></li><li><a href="1.3.html" class="sidebar-item" aria-label="RTFSC"><!--[--><!--]--> RTFSC <!--[--><!--]--></a><!----></li><li><a href="1.4.html" class="sidebar-item" aria-label="基础设施: 简易调试器"><!--[--><!--]--> 基础设施: 简易调试器 <!--[--><!--]--></a><!----></li><li><a href="1.5.html" class="sidebar-item" aria-label="表达式求值"><!--[--><!--]--> 表达式求值 <!--[--><!--]--></a><!----></li><li><a href="1.6.html" class="sidebar-item" aria-label="监视点"><!--[--><!--]--> 监视点 <!--[--><!--]--></a><!----></li><li><a href="1.7.html" class="sidebar-item" aria-label="如何阅读手册"><!--[--><!--]--> 如何阅读手册 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="PA2" class="sidebar-item sidebar-heading" aria-label="PA2 - 简单复杂的机器: 冯诺依曼计算机系统"><!--[--><!--]--> PA2 - 简单复杂的机器: 冯诺依曼计算机系统 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="2.1.html" class="sidebar-item" aria-label="不停计算的机器"><!--[--><!--]--> 不停计算的机器 <!--[--><!--]--></a><!----></li><li><a href="2.2.html" class="sidebar-item" aria-label="RTFM"><!--[--><!--]--> RTFM <!--[--><!--]--></a><!----></li><li><a href="2.3.html" class="sidebar-item" aria-label="程序, 运行时环境与AM"><!--[--><!--]--> 程序, 运行时环境与AM <!--[--><!--]--></a><!----></li><li><a href="2.4.html" class="sidebar-item" aria-label="基础设施(2)"><!--[--><!--]--> 基础设施(2) <!--[--><!--]--></a><!----></li><li><a href="2.5.html" class="sidebar-item" aria-label="输入输出"><!--[--><!--]--> 输入输出 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="PA3" class="sidebar-item sidebar-heading" aria-label="PA3 - 穿越时空的旅程: 批处理系统"><!--[--><!--]--> PA3 - 穿越时空的旅程: 批处理系统 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="3.1.html" class="sidebar-item" aria-label="批处理系统"><!--[--><!--]--> 批处理系统 <!--[--><!--]--></a><!----></li><li><a href="3.2.html" class="sidebar-item" aria-label="穿越时空的旅程"><!--[--><!--]--> 穿越时空的旅程 <!--[--><!--]--></a><!----></li><li><a href="3.3.html" class="sidebar-item" aria-label="用户程序和系统调用"><!--[--><!--]--> 用户程序和系统调用 <!--[--><!--]--></a><!----></li><li><a href="3.4.html" class="sidebar-item" aria-label="简易文件系统"><!--[--><!--]--> 简易文件系统 <!--[--><!--]--></a><!----></li><li><a href="3.5.html" class="sidebar-item" aria-label="精彩纷呈的应用程序"><!--[--><!--]--> 精彩纷呈的应用程序 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="PA4" class="sidebar-item sidebar-heading active" aria-label="PA4 - 虚实交错的魔法: 分时多任务"><!--[--><!--]--> PA4 - 虚实交错的魔法: 分时多任务 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="4.1.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="多道程序"><!--[--><!--]--> 多道程序 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="4.1.html#上下文切换" class="router-link-active router-link-exact-active sidebar-item" aria-label="上下文切换"><!--[--><!--]--> 上下文切换 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="4.1.html#基本原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="基本原理"><!--[--><!--]--> 基本原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="4.1.html#进程控制块" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程控制块"><!--[--><!--]--> 进程控制块 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="4.1.html#内核线程" class="router-link-active router-link-exact-active sidebar-item" aria-label="内核线程"><!--[--><!--]--> 内核线程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="4.1.html#用户进程" class="router-link-active router-link-exact-active sidebar-item" aria-label="用户进程"><!--[--><!--]--> 用户进程 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a href="4.2.html" class="sidebar-item" aria-label="程序和内存位置"><!--[--><!--]--> 程序和内存位置 <!--[--><!--]--></a><!----></li><li><a href="4.3.html" class="sidebar-item" aria-label="超越容量的界限"><!--[--><!--]--> 超越容量的界限 <!--[--><!--]--></a><!----></li><li><a href="4.4.html" class="sidebar-item" aria-label="分时多任务"><!--[--><!--]--> 分时多任务 <!--[--><!--]--></a><!----></li><li><a href="4.5.html" class="sidebar-item" aria-label="编写不朽的传奇"><!--[--><!--]--> 编写不朽的传奇 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="blank" class="sidebar-item sidebar-heading" aria-label="杂项"><!--[--><!--]--> 杂项 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="FAQ.html" class="sidebar-item" aria-label="常见问题(FAQ)"><!--[--><!--]--> 常见问题(FAQ) <!--[--><!--]--></a><!----></li><li><a href="why.html" class="sidebar-item" aria-label="为什么要学习计算机系统基础"><!--[--><!--]--> 为什么要学习计算机系统基础 <!--[--><!--]--></a><!----></li><li><a href="linux.html" class="sidebar-item" aria-label="Linux入门教程"><!--[--><!--]--> Linux入门教程 <!--[--><!--]--></a><!----></li><li><a href="man.html" class="sidebar-item" aria-label="man快速入门"><!--[--><!--]--> man快速入门 <!--[--><!--]--></a><!----></li><li><a href="git.html" class="sidebar-item" aria-label="git快速入门"><!--[--><!--]--> git快速入门 <!--[--><!--]--></a><!----></li><li><a href="nemu-isa-api.html" class="sidebar-item" aria-label="NEMU ISA相关的API说明文档"><!--[--><!--]--> NEMU ISA相关的API说明文档 <!--[--><!--]--></a><!----></li><li><a href="changelog.html" class="sidebar-item" aria-label="更新日志"><!--[--><!--]--> 更新日志 <!--[--><!--]--></a><!----></li><li><a href="i386-intro.html" class="sidebar-item" aria-label="x86指令系统简介"><!--[--><!--]--> x86指令系统简介 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="多道程序" tabindex="-1"><a class="header-anchor" href="4.1.html#多道程序" aria-hidden="true">#</a> 多道程序</h1><div class="custom-container c-red"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-bullhorn"></i> 甩锅声明</h4></span><p>从PA4开始, 讲义中就不再提供滴水不漏的代码指导了, 部分关键的代码细节需要你自己去思考和尝试(我们故意省略的). 我们会在讲义中将技术的原理阐述清楚, 你需要首先理解这些原理, 然后根据理解来阅读并编写相应的代码.</p><p>一句话总结, 与其抱怨讲义写得不清楚, 还不如自己多多思考. 现在都到PA4了, 为了让成绩符合正态分布, 拿高分总需要多付出点努力吧. 如果你之前都是想办法投机取巧而不去深入理解系统如何工作, 现在应该已经没戏了.</p></div><p>通过Nanos-lite的支撑, 我们已经在NEMU中成功运行了一个批处理系统, 并把仙剑奇侠传跑起来了! 这说明我们亲自构建的NEMU这个看似简单的机器, 同样能支撑真实程序的运行, 丝毫不逊色于真实的机器! 不过, 这个批处理系统目前还是只能同时运行一个程序, 只有当一个程序结束执行之后, 才会开始执行下一个程序.</p><p>这也正是批处理系统的一个缺陷: 如果当前程序正在等待输入输出, 那么整个系统都会因此而停顿. 在真实的计算机中, 和CPU的性能相比, 输入输出是非常缓慢的: 以磁盘为例, 磁盘进行一次读写需要花费大约5毫秒的时间, 但对于一个2GHz的CPU来说, 它需要花费10,000,000个周期来等待磁盘操作的完成. 但事实上, 与其让系统陷入无意义的等待, 还不如用这些时间来进行一些有意义的工作. 一个简单的想法就是, 在系统一开始的时候加载多个程序, 然后运行第一个; 当第一个程序需要等待输入输出的时候, 就切换到第二个程序来运行; 当第二个程序也需要等待的时候, 就继续切换到下一个程序来运行, 如此类推.</p><p>这就是<a href="https://en.wikipedia.org/wiki/Computer_multitasking#Multiprogramming" target="_blank" rel="noopener noreferrer">多道程序(multiprogramming)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>系统的基本思想. 多道程序的想法听上去很简单, 但它也是一种多任务系统, 这是因为它已经包含了多任务系统的基本要素. 换句话说, 要把批处理的Nanos-lite改造成一个多道程序操作系统, 我们只需要实现以下两点就可以了:</p><ul><li>在内存中可以同时存在多个进程</li><li>在满足某些条件的情况下, 可以让执行流在这些进程之间切换</li></ul><div class="custom-container c-green"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-lightbulb-o"></i> 术语变更</h4></span><p>既然是多任务系统, 系统中就运行的程序就不止一个了. 现在我们就可以直接使用&quot;进程&quot;的概念了.</p></div><p>要实现第一点并不难, 我们只要让loader把不同的进程加载到不同的内存位置就可以了, 加载进程的过程本质上就是一些内存拷贝的操作, 因此并没有什么困难的地方.</p><div class="custom-container c-blue"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-comment-o"></i> 其实我在骗你!</h4></span><p>对我们目前实现的计算机系统来说, &quot;把不同的进程加载到不同的内存位置&quot;其实是一件很麻烦的事情, 你能想明白为什么吗? 如果想不明白也没关系, 我们会在下一阶段详细讨论这个问题.</p></div><p>为了简单起见, 我们可以在Nanos-lite中直接定义一些测试函数来作为程序, 因为程序本质上就是一些有意义的指令序列, 目前我们不必在意这些指令序列到底从何而来. 不过, 一个需要注意的地方是栈, 我们需要为每个进程分配各自的栈空间.</p><div class="custom-container c-blue"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-question-circle"></i> 为什么需要使用不同的栈空间?</h4></span><p>如果不同的进程共享同一个栈空间, 会发生什么呢?</p></div><p>反而需要深思熟虑的是第二点: 表面上看, &quot;怎么让执行流在进程之间切换&quot;并不是一件直观的事情.</p><h2 id="上下文切换" tabindex="-1"><a class="header-anchor" href="4.1.html#上下文切换" aria-hidden="true">#</a> 上下文切换</h2><p>在PA3中, 我们已经提到了操作系统和用户进程之间的执行流切换, 并介绍了&quot;上下文&quot;的概念: 上下文的本质就是进程的状态. 换句话说, 我们现在需要考虑的是, 如何在多个用户进程之间进行上下文切换.</p><h3 id="基本原理" tabindex="-1"><a class="header-anchor" href="4.1.html#基本原理" aria-hidden="true">#</a> 基本原理</h3><p>事实上, 有了CTE, 我们就有一种很巧妙的方式来实现上下文切换了. 具体地, 假设进程A运行的过程中触发了系统调用, 陷入到内核. 根据<code>__am_asm_trap()</code>的代码, A的上下文结构(<code>Context</code>)将会被保存到A的栈上. 在PA3中, 系统调用处理完毕之后, <code>__am_asm_trap()</code>会根据栈上保存的上下文结构来恢复A的上下文. 神奇的地方来了, 如果我们先不着急恢复A的上下文, 而是先将栈顶指针切换到另一个进程B的栈上, 那会发生什么呢? 由于B的栈上存放了之前B保存的上下文结构, 接下来的操作就会根据这一结构来恢复B的上下文. 从<code>__am_asm_trap()</code>返回之后, 我们已经在运行进程B了!</p><p><img src="../assets/Context-switch.6ad11765.png" alt="context-switch"></p><p>那进程A到哪里去了呢? 别担心, 它只是被暂时&quot;挂起&quot;了而已. 在被挂起之前, 它已经把上下文结构保存到自己的栈上了, 如果将来的某一时刻栈顶指针被切换到A的栈上, 代码将会根据栈上的上下文结构来恢复A的上下文, A将得以唤醒并执行. 所以, 上下文切换其实就是不同进程之间的栈切换!</p><h3 id="进程控制块" tabindex="-1"><a class="header-anchor" href="4.1.html#进程控制块" aria-hidden="true">#</a> 进程控制块</h3><p>但是, 我们要如何找到别的进程的上下文结构呢? 注意到上下文结构是保存在栈上的, 但栈空间那么大, 受到函数调用形成的栈帧的影响, 每次保存上下文结构的位置并不是固定的. 自然地, 我们需要一个<code>cp</code>指针(context pointer)来记录上下文结构的位置, 当想要找到其它进程的上下文结构的时候, 只要寻找这个进程相关的<code>cp</code>指针即可.</p><p>事实上, 有不少信息都是进程相关的, 除了刚才提到的上下文指针<code>cp</code>之外, 上文提到的栈空间也是如此. 为了方便对这些进程相关的信息进行管理, 操作系统使用一种叫进程控制块(PCB, process control block)的数据结构, 为每一个进程维护一个PCB. Nanos-lite的框架代码中已经定义了我们所需要使用的PCB结构(在<code>nanos-lite/include/proc.h</code>中定义):</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">union</span> <span class="token punctuation">{</span>
  <span class="token class-name">uint8_t</span> stack<span class="token punctuation">[</span>STACK_SIZE<span class="token punctuation">]</span> PG_ALIGN<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Context <span class="token operator">*</span>cp<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> PCB<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>PCB中还定义了其它成员, 目前可以忽略它们, 我们会在将来介绍它们.</p><p>Nanos-lite使用一个联合体来把其它信息放置在进程堆栈的底部. 代码为每一个进程分配了一个32KB的堆栈, 已经足够使用了, 不会出现栈溢出导致UB. 在进行上下文切换的时候, 只需要把PCB中的<code>cp</code>指针返回给CTE的<code>__am_irq_handle()</code>函数即可, 剩余部分的代码会根据上下文结构恢复上下文. 我们只要稍稍借助数学归纳法, 就可以让我们相信这个过程对于正在运行的进程来说总是正确的.</p><p>那么, 对于刚刚加载完的进程, 我们要怎么切换到它来让它运行起来呢?</p><h3 id="内核线程" tabindex="-1"><a class="header-anchor" href="4.1.html#内核线程" aria-hidden="true">#</a> 内核线程</h3><h4 id="创建内核线程上下文" tabindex="-1"><a class="header-anchor" href="4.1.html#创建内核线程上下文" aria-hidden="true">#</a> 创建内核线程上下文</h4><p>答案很简单, 我们只需要在进程的栈上人工创建一个上下文结构, 使得将来切换的时候可以根据这个结构来正确地恢复上下文即可.</p><p>上文提到, 我们先把Nanos-lite中直接定义的一些测试函数作为程序. Nanos-lite提供了一个测试函数<code>hello_fun()</code>(在<code>nanos-lite/src/proc.c</code>中定义), 我们接下来的任务就是为它创建一个上下文, 然后切换到它来执行. 这样的执行流有一个专门的名称, 叫&quot;内核线程&quot;(kernel thread).</p><div class="custom-container c-blue"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-comment-o"></i> 为什么不叫&quot;内核进程&quot;?</h4></span><p>这个问题其实等价于&quot;进程和线程有什么区别&quot;, 是个不错的问题. 而且这还属于考研八股的内容呢, 于是你肯定可以通过STFW找到很多五花八门的答案, 比如&quot;线程更加轻量级&quot;, &quot;线程没有独立的资源&quot;等等.</p><p>如果要进一步解释&quot;什么是轻量级&quot;, &quot;独立的资源是什么意思&quot;, 在PA中可能比较困难. 不过在PA中也不必深究这个问题, 目前你只需要把它们都看成执行流就可以了, 更重要的是, 这两者你都将会实现, 在代码中亲自去感受它们的区别不是一个更好的选择吗? 另外, 带着这个问题去修读下学期的操作系统课也不错.</p></div><p>创建内核线程的上下文是通过CTE提供的<code>kcontext()</code>函数 (在<code>abstract-machine/am/src/$ISA/nemu/cte.c</code>中定义)来实现的, 其中的&quot;k&quot;代表内核. <code>kcontext()</code>的原型是</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code>Context<span class="token operator">*</span> <span class="token function">kcontext</span><span class="token punctuation">(</span>Area kstack<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>entry<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中<code>kstack</code>是栈的范围, <code>entry</code>是内核线程的入口, <code>arg</code>则是内核线程的参数. 你需要在<code>kstack</code>的底部创建一个以<code>entry</code>为返回地址的上下文结构(目前你可以先忽略<code>arg</code>参数), 然后返回这一结构的指针.</p><p>在Nanos-lite中, 我们可以通过一个<code>context_kload()</code>函数来进行进一步的封装: 它会调用<code>kcontext()</code>来创建上下文, 并把返回的指针记录到PCB的<code>cp</code>中:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>|               |
+---------------+ &lt;---- kstack.end
|               |
|    context    |
|               |
+---------------+ &lt;--+
|               |    |
|               |    |
|               |    |
|               |    |
+---------------+    |
|       cp      | ---+
+---------------+ &lt;---- kstack.start
|               |
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="线程-进程调度" tabindex="-1"><a class="header-anchor" href="4.1.html#线程-进程调度" aria-hidden="true">#</a> 线程/进程调度</h4><p>上下文的创建和切换是CTE的工作, 而具体切换到哪个上下文, 则是由操作系统来决定的, 这项任务叫做进程调度. 进程调度是由<code>schedule()</code>函数(在<code>nanos-lite/src/proc.c</code>中定义)来完成的, 它用于返回将要调度的进程上下文. 因此, 我们需要一种方式来记录当前正在运行哪一个进程, 这样我们才能在<code>schedule()</code>中返回另一个进程的上下文, 以实现多任务的效果. 这一工作是通过<code>current</code>指针(在<code>nanos-lite/src/proc.c</code>中定义)来实现的, 它用于指向当前运行进程的PCB. 这样, 我们就可以在<code>schedule()</code>中通过<code>current</code>来决定接下来要调度哪一个进程了. 不过在调度之前, 我们还需要把当前进程的上下文指针保存在PCB当中:</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// save the context pointer</span>
current<span class="token operator">-&gt;</span>cp <span class="token operator">=</span> prev<span class="token punctuation">;</span>

<span class="token comment">// always select pcb[0] as the new process</span>
current <span class="token operator">=</span> <span class="token operator">&amp;</span>pcb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// then return the new context</span>
<span class="token keyword">return</span> current<span class="token operator">-&gt;</span>cp<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>目前我们让<code>schedule()</code>总是切换到<code>pcb[0]</code>. 注意它的上下文是通过<code>kcontext()</code>创建的, 在<code>schedule()</code>中才决定要切换到它, 然后在CTE的<code>__am_asm_trap()</code>中才真正地恢复这一上下文.</p><div class="custom-container c-blue"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-comment-o"></i> 机制和策略解耦</h4></span><p>这其实体现了系统设计中的一种重要原则: 机制和策略解耦. 机制解决的是&quot;能不能做&quot;的问题, 而策略解决的则是&quot;怎么做好&quot;的问题. 显然, 策略需要机制的支撑, 机制需要策略来发挥最大的效果.</p><p>解耦的好处就很明显了: 代码重用率高, 而且容易理解. 在Project-N中, 这一解耦几乎做到了极致: 机制和策略被分离到两个子项目中. 比如, &quot;上下文切换&quot;这一机制是在AM的CTE中实现的, 它让系统可以做到&quot;执行流的切换&quot;这件事; 而具体要切换到哪一个执行流, 则是在Nanos-lite中实现的.</p><p>AM的另外一个好处是将底层硬件的行为抽象成系统级机制, AM上的应用(包括OS)只需要调用这些系统级机制, 并实现相应的策略即可. 当然目前<code>schedule()</code>中的策略非常简单, 下学期的操作系统实验, 甚至是现实中更复杂的进程调度策略, 都可以在AM提供的同一个机制之上实现.</p></div><div class="custom-container c-yellow"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-edit"></i> 实现上下文切换</h4></span><p>根据讲义的上述内容, 实现以下功能:</p><ul><li>CTE的<code>kcontext()</code>函数</li><li>Nanos-lite的<code>context_kload()</code>函数(框架代码未给出该函数的原型)</li><li>Nanos-lite的<code>schedule()</code>函数</li><li>在Nanos-lite收到<code>EVENT_YIELD</code>事件后, 调用<code>schedule()</code>并返回新的上下文</li><li>修改CTE中<code>__am_asm_trap()</code>的实现, 使得从<code>__am_irq_handle()</code>返回后, 先将栈顶指针切换到新进程的上下文结构, 然后才恢复上下文, 从而完成上下文切换的本质操作</li></ul><p>你需要在<code>init_proc()</code>中单独创建一个以<code>hello_fun</code>为返回地址的上下文:</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">init_proc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">context_kload</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pcb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> hello_fun<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">switch_boot_pcb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中调用<code>switch_boot_pcb()</code>是为了初始化<code>current</code>指针. 如果你的实现正确, 你将会看到<code>hello_fun()</code>中的输出信息. 需要注意的是, 虽然<code>hello_fun()</code>带有一个参数<code>arg</code>, 但目前我们并不使用它, 所以<code>kcontext()</code>中的<code>arg</code>参数也可以先忽略, 我们接下来就会考虑它.</p></div><div class="custom-container c-green"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-lightbulb-o"></i> 一些提示</h4></span><p><code>schedule()</code>函数很容易, 需要思考的是<code>kcontext()</code>. 我们希望代码将来从<code>__am_asm_trap()</code>返回之后, 就会开始执行<code>hello_fun()</code>. 换句话说, 我们需要在<code>kcontext()</code>中构造一个上下文, 它指示了一个状态, 从这个状态开始, 可以正确地开始执行<code>hello_fun()</code>. 所以你需要思考的是, 为了可以正确地开始执行<code>hello_fun()</code>, 这个状态究竟需要满足什么样的条件?</p><p>至于&quot;先将栈顶指针切换到新进程的上下文结构&quot;, 很自然的问题就是, 新进程的上下文结构在哪里? 怎么找到它? 又应该怎么样把栈顶指针切换过去? 如果你发现代码跑飞了, 不要忘记, 程序是个状态机.</p></div><div class="custom-container c-green"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-lightbulb-o"></i> 在native上进行上下文切换</h4></span><p>由于native的AM在创建上下文的时候默认会打开中断, 为了让Nanos-lite可以成功运行native创建的内核线程, 你还需要在Nanos-lite中识别出时钟中断事件. 我们会在PA4的最后介绍时钟中断相关的内容, 目前识别出时钟中断事件之后什么都不用做, 直接返回相应的上下文结构即可.</p></div><div class="custom-container c-green"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-lightbulb-o"></i> 配合DiffTest</h4></span><p>为了保证DiffTest的正确运行, 根据你选择的ISA, 你还需要进行一些额外的设置:</p><ul><li>x86: 把上下文结构中的<code>cs</code>设置为<code>8</code>.</li><li>riscv32: 把上下文结构中的<code>mstatus</code>设置为<code>0x1800</code>.</li><li>riscv64, 把上下文结构中的<code>mstatus</code>设置为<code>0xa00001800</code>.</li></ul></div><h4 id="内核线程的参数" tabindex="-1"><a class="header-anchor" href="4.1.html#内核线程的参数" aria-hidden="true">#</a> 内核线程的参数</h4><p>你也许会疑惑, 不就是执行<code>hello_fun()</code>函数吗, 为什么不能直接调用它, 搞这么复杂, 究竟有什么好处? 现在我们就来展示其中的好处. 还记得<code>hello_fun()</code>带了一个<code>arg</code>参数吗? 我们来创建两个内核线程, 给它们传递不同的参数, 然后在输出的信息中把参数也一同输出, 这样我们就能看到执行流在两个内核线程之间来回切换了!</p><p>首先需要解决的第一个问题是, 我们要如何通过<code>kcontext()</code>给<code>hello_fun()</code>传参? 于是我们需要继续思考, <code>hello_fun()</code>将会如何读出它的参数? 噢, 这不就是调用约定的内容吗? 你已经非常熟悉了. 我们只需要让<code>kcontext()</code>按照调用约定将<code>arg</code>放置在正确的位置, 将来<code>hello_fun()</code>执行的时候就可以获取正确的参数了.</p><div class="custom-container c-blue"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-question-circle"></i> mips32和riscv32的调用约定</h4></span><p>我们没有给出mips32和riscv32的调用约定, 你需要查阅相应的ABI手册. 当然, 你也可以自己动手实践来总结传参的规则.</p></div><p>第二个问题是如何在两个内核线程之间来回切换. <code>hello_fun()</code>中每次输出完信息都会调用<code>yield()</code>, 因此我们只需要对<code>schedule()</code>进行简单的修改即可:</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code>current <span class="token operator">=</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token operator">&amp;</span>pcb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token operator">&amp;</span>pcb<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token operator">&amp;</span>pcb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="custom-container c-yellow"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-edit"></i> 实现上下文切换(2)</h4></span><p>根据讲义的上述内容, 实现以下功能:</p><ul><li>修改CTE的<code>kcontext()</code>函数, 使其支持参数<code>arg</code>的传递</li><li>通过<code>kcontext()</code>创建第二个以<code>hello_fun()</code>为入口的内核线程, 并传递不同的参数</li><li>修改Nanos-lite的<code>schedule()</code>函数, 使其轮流返回两个上下文</li></ul><p>你可以自行约定用何种类型来解析参数<code>arg</code>(整数, 字符, 字符串, 指针等皆可), 然后修改<code>hello_fun()</code>中的输出代码, 来按照你约定的方式解析<code>arg</code>. 如果你的实现正确, 你将会看到<code>hello_fun()</code>会轮流输出不同参数的信息.</p></div><p>在真实的操作系统中, 内核中的很多后台任务, 守护服务和驱动程序都是以内核线程的形式存在的. 如果你执行<code>ps aux</code>, 你就会看到系统中有很多COMMAND中带有中括号的内核线程(例如<code>[kthreadd]</code>). 而创建和执行它们的原理, 也是和上面的实验内容非常相似(当然具体实现肯定会有所不同).</p><div class="custom-container c-blue"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-edit"></i> 保持kcontext()的特性</h4></span><p>AM在定义<code>kcontext()</code>的行为时, 还要求<code>kcontext()</code>只能在栈上放置一个上下文结构, 而不能放置更多的内容. 这样的要求有两点好处:</p><ul><li><code>kcontext()</code>对栈的写入只有一个上下文结构的内容, 而不会产生其它的副作用</li><li>OS可以预测调用<code>kcontext()</code>之后的返回值, 并且利用这一确定的特性进行一些检查或者简化某些实现</li></ul><p>我们知道x86是通过栈来传递参数的, 如果<code>kcontext()</code>需要支持<code>arg</code>的传递, 它就需要往栈上放置更多的内容, 这样就违反了上述确定性了. 但在PA中, 这并不会导致致命的问题, 因此我们并不要求你的<code>kcontext()</code>实现严格遵守这一确定性. 但你还是可以思考如何在遵守确定性的情况下实现参数的传递.</p><p>一个解决方案是通过引入一个辅助函数来将真正的参数传递从<code>kcontext()</code>推迟到内核线程的运行时刻. 具体地, 我们可以在<code>kcontext()</code>中先把内核线程的入口设置为辅助函数, 并把参数设置到某个可用的寄存器中. 这样以后, 内核线程就会从辅助函数开始执行, 此时让辅助函数来把之前设置的参数从寄存器中放置到栈上, 再调用真正的线程入口函数(<code>hello_fun()</code>). 这一方案和Linux中加载用户程序还是有一些相似之处的: 用户程序在运行的时候也并不是直接把<code>main()</code>函数作为入口, 而是先从CRT定义的<code>_start()</code>开始运行, 进行包括设置参数在内的一系列初始化操作, 最后才调用<code>main()</code>函数.</p><p>如果你选择的ISA是x86, 你可以尝试在CTE中实现上述辅助函数. 考虑到要直接操作寄存器和栈, 这个辅助函数还是通过汇编代码来编写比较合适. 不过由于这个辅助函数的功能比较简单, 你只需要编写几条指令就可以实现它了.</p></div><h3 id="用户进程" tabindex="-1"><a class="header-anchor" href="4.1.html#用户进程" aria-hidden="true">#</a> 用户进程</h3><h4 id="创建用户进程上下文" tabindex="-1"><a class="header-anchor" href="4.1.html#创建用户进程上下文" aria-hidden="true">#</a> 创建用户进程上下文</h4><p>创建用户进程的上下文则需要一些额外的考量. 在PA3的批处理系统中, 我们在<code>naive_uload()</code>中直接通过函数调用转移到用户进程的代码, 那时候使用的还是内核区的栈, 万一发生了栈溢出, 确实会损坏操作系统的数据, 不过当时也只有一个用户进程在运行, 我们也就不追究了. 但在多道程序操作系统中, 系统中运行的进程就不止一个了, 如果让用户进程继续使用内核区的栈, 万一发生了栈溢出, 就会影响到其它进程的运行, 这是我们不希望看到的.</p><div class="custom-container c-blue"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-comment-o"></i> 如果内核线程发生了栈溢出, 怎么办?</h4></span><p>如果能检测出来, 最好的方法就是触发kernel panic, 因为这时候内核的数据已经不再可信, 如果将一个被破坏的数据写回磁盘, 将会造成无法恢复的毁灭性损坏.</p><p>好消息是, 内核线程的正确性可以由内核开发人员来保证, 这至少要比保证那些来路不明的用户进程的正确性要简单多了. 而坏消息则是, 大部分的内核bug都是第三方驱动程序导致的: 栈溢出算是少见的了, 更多的是use-after-free, double-free, 还有难以捉摸的并发bug. 而面对海量的第三方驱动程序, 内核开发人员也难以逐一保证其正确性. 如果你想到一个可以提升驱动程序代码质量的方法, 那就是为计算机系统领域作出贡献了.</p></div><p>因此, 和内核线程不同, 用户进程的代码, 数据和堆栈都应该位于用户区, 而且需要保证用户进程能且只能访问自己的代码, 数据和堆栈. 为了区别开来, 我们把PCB中的栈称为内核栈, 位于用户区的栈称为用户栈. 于是我们需要一个有别于<code>kcontext()</code>的方式来创建用户进程的上下文, 为此AM额外准备了一个API <code>ucontext()</code>(在<code>abstract-machine/am/src/nemu/isa/$ISA/vme.c</code>中定义), 它的原型是</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code>Context<span class="token operator">*</span> <span class="token function">ucontext</span><span class="token punctuation">(</span>AddrSpace <span class="token operator">*</span>as<span class="token punctuation">,</span> Area kstack<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中, 参数<code>as</code>用于限制用户进程可以访问的内存, 我们在下一阶段才会使用, 目前可以忽略它; <code>kstack</code>是内核栈, 用于分配上下文结构, <code>entry</code>则是用户进程的入口. 由于目前我们忽略了<code>as</code>参数, 所以<code>ucontext()</code>的实现和<code>kcontext()</code>几乎一样, 甚至比<code>kcontext()</code>更简单: 连参数都不需要传递. 不过你还是需要思考, 对于用户进程来说, 它需要一个什么样的状态来开始执行呢?</p><p>咦, 说好的用户栈呢? 事实上, 用户栈的分配是ISA无关的, 所以用户栈相关的部分就交给Nanos-lite来进行, <code>ucontext()</code>无需处理. 目前我们让Nanos-lite把<code>heap.end</code>作为用户进程的栈顶, 然后把这个栈顶赋给用户进程的栈指针寄存器就可以了.</p><p>哎呀, 栈指针寄存器可是ISA相关的, 在Nanos-lite里面不方便处理. 别着急, 还记得用户进程的那个<code>_start</code>吗? 在那里可以进行一些ISA相关的操作. 于是Nanos-lite和Navy作了一项约定: Nanos-lite把栈顶位置设置到GPRx中, 然后由Navy里面的<code>_start</code>来把栈顶位置真正设置到栈指针寄存器中.</p><p>Nanos-lite可以把上述工作封装到<code>context_uload()</code>函数中, 这样我们就可以加载用户进程了. 我们把其中一个<code>hello_fun()</code>内核线程替换成仙剑奇侠传:</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token function">context_uload</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pcb<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">&quot;/bin/pal&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后我们还需要在<code>serial_write()</code>, <code>events_read()</code> 和<code>fb_write()</code>的开头调用<code>yield()</code>, 来模拟设备访问缓慢的情况. 添加之后, 访问设备时就要进行上下文切换, 从而实现多道程序系统的功能.</p><div class="custom-container c-yellow"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-edit"></i> 实现多道程序系统</h4></span><p>根据讲义的上述内容, 实现以下功能, 从而实现多道程序系统:</p><ul><li>VME的<code>ucontext()</code>函数</li><li>Nanos-lite的<code>context_uload()</code>函数(框架代码未给出该函数的原型)</li><li>在Navy的<code>_start</code>中设置正确的栈指针</li></ul><p>如果你的实现正确, 你将可以一边运行仙剑奇侠传的同时, 一边输出hello信息. 需要注意的是, 为了让AM native正确运行, 你也需要在Navy的<code>_start</code>中设置正确的栈指针.</p><p>思考一下, 如何验证仙剑奇侠传确实在使用用户栈而不是内核栈?</p></div><div class="custom-container c-blue"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-question-circle"></i> 一山不能藏二虎?</h4></span><p>尝试把<code>hello_fun()</code>换成Navy中的<code>hello</code>:</p><div class="language-diff ext-diff line-numbers-mode"><pre class="language-diff"><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">context_kload(&amp;pcb[0], (void *)hello_fun, NULL);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">context_uload(&amp;pcb[0], &quot;/bin/hello&quot;);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">context_uload(&amp;pcb[1], &quot;/bin/pal&quot;);
</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你发现了什么问题? 为什么会这样? 思考一下, 答案会在下一阶段揭晓!</p></div><h4 id="用户进程的参数" tabindex="-1"><a class="header-anchor" href="4.1.html#用户进程的参数" aria-hidden="true">#</a> 用户进程的参数</h4><p>我们在实现内核线程的时候, 给它传递了一个<code>arg</code>参数. 事实上, 用户进程也可以有自己的参数, 那就是你在程序设计课上学习过的<code>argc</code>和<code>argv</code>了, 还有一个你也许不怎么熟悉的<code>envp</code>. <code>envp</code>是环境变量指针, 它指向一个字符串数组, 字符串的格式都是形如<code>xxx=yyy</code>, 表示有一个名为<code>xxx</code>的变量, 它的值为<code>yyy</code>. 我们在PA0中通过<code>init.sh</code>初始化PA项目的时候, 它会在<code>.bashrc</code>文件中定义一些环境变量, 比如<code>AM_HOME</code>. 当我们编译FCEUX的时候, <code>make</code>程序就会解析<code>fceux-am/Makefile</code>中的内容, 当遇到</p><div class="language-make ext-make line-numbers-mode"><pre class="language-make"><code>include $(AM_HOME)/Makefile
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>的时候, 就会尝试通过<code>getenv()</code>这个库函数在<code>envp</code>指向的字符串数组里面寻找是否有形如 <code>AM_HOME=yyy</code>的字符串, 如果有, 就返回<code>yyy</code>. 如果<code>AM_HOME</code>指向了正确的路径, <code>make</code>程序就可以找到<code>abstract-machine</code>项目中的<code>Makefile</code>文件并包含进来.</p><p>事实上, <code>main()</code>函数完整的原型应该是</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>那么, 当我们在终端里面键入</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>x86-nemu run
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>的时候, <code>ARCH=x86-nemu</code>和<code>run</code>这两个参数以及环境变量都是怎么传递给<code>make</code>程序的<code>main()</code>函数的呢?</p><p>既然用户进程是操作系统来创建的, 很自然参数和环境变量的传递就需要由操作系统来负责. 最适合存放参数和环境变量的地方就是用户栈了, 因为在首次切换到用户进程的时候, 用户栈上的内容就已经可以被用户进程访问. 于是操作系统在加载用户进程的时候, 还需要负责把<code>argc/argv/envp</code>以及相应的字符串放在用户栈中, 并把它们的存放方式和位置作为和用户进程的约定之一, 这样用户进程在<code>_start</code>中就可以根据约定访问它们了.</p><p>这项约定其实属于ABI的内容, ABI手册有一节Process Initialization的内容, 里面详细约定了操作系统需要为用户进程的初始化提供哪些信息. 不过在我们的Project-N系统里面, 我们只需要一个简化版的Process Initialization就够了: 操作系统将<code>argc/argv/envp</code>及其相关内容放置到用户栈上, 然后将GPRx设置为<code>argc</code>所在的地址.</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>|               |
+---------------+ &lt;---- ustack.end
|  Unspecified  |
+---------------+
|               | &lt;----------+
|    string     | &lt;--------+ |
|     area      | &lt;------+ | |
|               | &lt;----+ | | |
|               | &lt;--+ | | | |
+---------------+    | | | | |
|  Unspecified  |    | | | | |
+---------------+    | | | | |
|     NULL      |    | | | | |
+---------------+    | | | | |
|    ......     |    | | | | |
+---------------+    | | | | |
|    envp[1]    | ---+ | | | |
+---------------+      | | | |
|    envp[0]    | -----+ | | |
+---------------+        | | |
|     NULL      |        | | |
+---------------+        | | |
| argv[argc-1]  | -------+ | |
+---------------+          | |
|    ......     |          | |
+---------------+          | |
|    argv[1]    | ---------+ |
+---------------+            |
|    argv[0]    | -----------+
+---------------+
|      argc     |
+---------------+ &lt;---- cp-&gt;GPRx
|               |
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上图把这些参数分成两部分, 一部分是字符串区域(string area), 另一部分是<code>argv/envp</code>这两个字符串指针数组, 数组中的每一个元素是一个字符串指针, 而这些字符串指针都会指向字符串区域中的某个字符串. 此外, 上图中的<code>Unspecified</code>表示一段任意长度(也可为0)的间隔, 字符串区域中各个字符串的顺序也不作要求, 只要用户进程可以通过<code>argv/envp</code>访问到正确的字符串即可. 这些参数的放置格式与ABI手册中的描述非常类似, 你也可以参考ICS课本第七章的某个图.</p><div class="custom-container c-blue"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-comment-o"></i> 阅读ABI手册, 理解计算机系统</h4></span><p>事实上, ABI手册是ISA, OS, 编译器, 运行时环境, C语言和用户进程的桥梁, 非常值得大家去阅读. ICS课本上那些让你摸不着头脑的约定, 大部分也是出自ABI手册. Linux上遵守的ABI是System V ABI, 它又分为两部分, 一部分是和处理器无关的generic ABI(gABI), 例如ELF格式, 动态连接, 文件系统结构等; 另一部分是和处理器相关的processor specific ABI(psABI), 例如调用约定, 操作系统接口, 程序加载等. 你至少也应该去看看ABI手册的目录, 翻一下正文部分的图, 这样你就会对ABI手册有一个大致的了解. 如果你愿意深入推敲一下&quot;为什么这样约定&quot;, 那就是真正的&quot;深入理解计算机系统了&quot;.</p></div><p>根据这一约定, 你还需要修改Navy中<code>_start</code>的代码, 把<code>argc</code>的地址作为参数传递给<code>call_main()</code>. 然后修改<code>call_main()</code>的代码, 让它解析出真正的<code>argc/argv/envp</code>, 并调用<code>main()</code>:</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">call_main</span><span class="token punctuation">(</span><span class="token class-name">uintptr_t</span> <span class="token operator">*</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  argc <span class="token operator">=</span> <span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span>
  argv <span class="token operator">=</span> <span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span>
  envp <span class="token operator">=</span> <span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span>
  environ <span class="token operator">=</span> envp<span class="token punctuation">;</span>
  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token function">main</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> envp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样以后, 用户进程就可以接收到属于它的参数了.</p><div class="custom-container c-yellow"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-edit"></i> 给用户进程传递参数</h4></span><p>这个任务的本质是一个指针相关的编程练习, 不过你需要注意编写可移植的代码, 因为<code>call_main()</code>是被各种ISA所共享的. 然后修改仙剑奇侠传的少量代码, 如果它接收到一个<code>--skip</code>参数, 就跳过片头商标动画的播放, 否则不跳过. 实现这个功能将有利于加速仙剑奇侠传的测试. 商标动画的播放从代码逻辑上距离<code>main()</code>函数并不远, 于是就交给你来RTFSC吧.</p><p>不过为了给用户进程传递参数, 你还需要修改<code>context_uload()</code>的原型:</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">context_uload</span><span class="token punctuation">(</span>PCB <span class="token operator">*</span>pcb<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样你就可以在<code>init_proc()</code>中直接给出用户进程的参数来测试了: 在创建仙剑奇侠传用户进程的时候给出<code>--skip</code>参数, 你需要观察到仙剑奇侠传确实跳过了商标动画. 目前我们的测试程序中不会用到环境变量, 所以不必传递真实的环境变量字符串. 至于实参应该写什么, 这又是一个指针相关的问题, 就交给你来解决吧.</p></div><p>让操作系统为每一个用户进程手动设定参数是一件不现实的事情, 因为用户进程的参数还是应该由用户来指定的. 于是最好能有一个方法能把用户指定的参数告诉操作系统, 让操作系统来把指定的参数放到新进程的用户栈里面. 这个方法当然就是系统调用<code>SYS_execve</code>啦, 如果你去看<code>man</code>, 你会发现它的原型是</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">execve</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="custom-container c-blue"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-question-circle"></i> 为什么少了一个const?</h4></span><p>在<code>main()</code>函数中, <code>argv</code>和<code>envp</code>的类型是<code>char * []</code>, 而在<code>execve()</code>函数中, 它们的类型则是<code>char *const []</code>. 从这一差异来看, <code>main()</code>函数中<code>argv</code>和<code>envp</code>所指向的字符串是可写的, 你知道为什么会这样吗?</p></div><p>为了实现带参数的<code>SYS_execve</code>, 我们可以在<code>sys_execve()</code>中直接调用<code>context_uload()</code>. 但我们还需要考虑如下的一些细节, 为了方便描述, 我们假设用户进程A将要通过<code>SYS_execve</code>来执行另一个新程序B.</p><ul><li>如何在A的执行流中创建用户进程B?</li><li>如何结束A的执行流?</li></ul><p>为了回答第一个问题, 我们需要回顾创建用户进程B需要进行哪些操作. 首先是在PCB的内核栈中创建B的上下文结构, 这个过程是安全的, 因为当前进程的内核栈是空的. 接下来就是要在用户栈中放置用户进程B的参数. 但这会涉及到一个新的问题: 我们是否还能复用位于<code>heap.end</code>附近的同一个用户栈?</p><p>为了探究这个问题, 我们需要了解当Nanos-lite尝试通过<code>SYS_execve</code>加载B时, A的用户栈里面已经有什么内容. 我们可以从栈底(<code>heap.end</code>)到栈顶(栈指针<code>sp</code>当前的位置)列出用户栈中的内容:</p><ul><li>Nanos-lite之前为A传递的用户进程参数(<code>argc/argv/envp</code>)</li><li>A从<code>_start</code>开始进行函数调用的栈帧, 这个栈帧会一直生长, 直到调用了libos中的<code>execve()</code></li><li>CTE保存的上下文结构, 这是由于A在<code>execve()</code>中执行了系统调用自陷指令导致的</li><li>Nanos-lite从<code>__am_irq_handle()</code>开始进行函数调用的栈帧, 这个栈帧会一直生长, 直到调用了<code>SYS_execve</code>的系统调用处理函数</li></ul><p>通过上述分析, 我们得出一个重要的结论: 在加载B时, Nanos-lite使用的是A的用户栈! 这意味着在A的执行流结束之前, A的用户栈是不能被破坏的. 因此<code>heap.end</code>附近的用户栈是不能被B复用的, 我们应该申请一段新的内存作为B的用户栈, 来让Nanos-lite把B的参数放置到这个新分配的用户栈里面.</p><p>为了实现这一点, 我们可以让<code>context_uload()</code>统一通过调用<code>new_page()</code>函数来获得用户栈的内存空间. <code>new_page()</code>函数在<code>nanos-lite/src/mm.c</code>中定义, 它会通过一个<code>pf</code>指针来管理堆区, 用于分配一段大小为<code>nr_page * 4KB</code>的连续内存区域, 并返回这段区域的首地址. 我们让<code>context_uload()</code>通过<code>new_page()</code>来分配32KB的内存作为用户栈, 这对PA中的用户程序来说已经足够使用了. 此外为了简化, 我们在PA中无需实现<code>free_page()</code>.</p><div class="custom-container c-blue"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-comment-o"></i> 操作系统的内存管理</h4></span><p>我们知道klib中的<code>malloc()</code>函数也可以进行堆区的管理, 使得AM应用可以方便地进行动态内存申请. 但操作系统作为一个特殊的AM应用, 很多时候对动态内存申请却有更严格的要求, 例如申请一段起始地址是4KB整数倍的内存区域, <code>malloc()</code>通常不能满足这样的要求. 因此操作系统一般都会自己来管理堆区, 而不会调用klib中的<code>malloc()</code>. 在操作系统中管理堆区是MM(Memory Manager)模块的工作, 我们会在后续内容中进一步介绍它.</p></div><p>最后, 为了结束A的执行流, 我们可以在创建B的上下文之后, 通过<code>switch_boot_pcb()</code>修改当前的<code>current</code>指针, 然后调用<code>yield()</code>来强制触发进程调度. 这样以后, A的执行流就不会再被调度, 等到下一次调度的时候, 就可以恢复并执行B了.</p><div class="custom-container c-yellow"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-edit"></i> 实现带参数的execve()</h4></span><p>根据上述讲义内容, 实现带参数的<code>execve()</code>. 有一些细节我们并没有完全给出, 例如调用<code>context_uload()</code>的<code>pcb</code>参数应该传入什么内容, 这个问题就交给你来思考吧!</p><p>实现后, 运行以下程序:</p><ul><li>测试程序<code>navy-apps/tests/exec-test</code>, 它会以参数递增的方式不断地执行自身. 不过由于我们没有实现堆区内存的回收, <code>exec-test</code>在运行一段时间之后, <code>new_page()</code>就会把<code>0x3000000</code>/<code>0x83000000</code>附近的内存分配出去, 导致用户进程的代码段被覆盖. 目前我们无法修复这一问题, 你只需要看到<code>exec-test</code>可以正确运行一段时间即可.</li><li>MENU开机菜单.</li><li>完善NTerm的內建Shell, 使得它可以解析输入的参数, 并传递给启动的程序. 例如可以在NTerm中键入<code>pal --skip</code>来运行仙剑奇侠传并跳过商标动画.</li></ul></div><h4 id="运行busybox" tabindex="-1"><a class="header-anchor" href="4.1.html#运行busybox" aria-hidden="true">#</a> 运行Busybox</h4><p>我们已经成功运行了NTerm, 但却没多少Shell工具可以运行. <a href="https://www.busybox.net/about.html" target="_blank" rel="noopener noreferrer">Busybox<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>正是用来解决这个问题的, 它是一个精简版Shell工具的集合, 包含了大部分常用命令的常用功能. 噢, 你平时在Linux中使用命令行的经历, 很快就可以在你自己构建的计算机系统里面呈现了!</p><p>Navy的框架代码已经准备了Busybox的编译脚本, 首次编译Busybox时脚本会自动克隆项目, 并使用框架代码提供的配置文件. Busybox中包含很多小工具, 你可以通过</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>make menuconfig
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>来打开一个配置菜单来查看它们(但不要保存对配置的修改). 框架代码提供的配置文件默认只选中了很少的工具, 这是因为大部分工具都需要更多系统调用的支持才能运行, 因此我们无法在Nanos-lite上运行它们.</p><p>Busybox会把其中的Shell工具链接成一个ELF可执行文件, 而不是像Ubuntu/Debian等发行版中的Shell工具那样, 每个工具都是独立的ELF可执行文件. Busybox的<code>main()</code>函数会根据传入的参数来调用相应工具的功能:</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">&quot;cat&quot;</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">cat_main</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">&quot;ls&quot;</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">ls_main</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">&quot;wc&quot;</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">wc_main</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ......</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Busybox提供了一个简单的安装脚本, 通过创建一系列的软链接来让用户方便地使用这些小工具:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>$ ls -lh navy-apps/fsimg/bin
total 1.6M
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 base64 -&gt; busybox
-rwxr-xr-x 1 yzh yzh 161K Oct 21 12:11 bird
-rwxr-xr-x 1 yzh yzh 126K Dec  9 12:12 busybox
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 cat -&gt; busybox
-rwxr-xr-x 1 yzh yzh  33K Oct 20 20:43 cpp-test
-rwxr-xr-x 1 yzh yzh  29K Dec  9 12:12 dummy
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 echo -&gt; busybox
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 ed -&gt; busybox
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 false -&gt; busybox
-rwxr-xr-x 1 yzh yzh  33K Dec  9 12:12 hello
-rwxr-xr-x 1 yzh yzh  81K Dec  9 12:12 menu
-rwxr-xr-x 1 yzh yzh  91K Dec  9 12:12 nterm
-rwxr-xr-x 1 yzh yzh 586K Dec  9 12:12 onscripter
-rwxr-xr-x 1 yzh yzh 390K Dec  9 12:12 pal
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 printenv -&gt; busybox
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 sleep -&gt; busybox
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 true -&gt; busybox
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样以后, 我们键入<code>cat</code>命令, 实际上是执行<code>/bin/busybox</code>, 来让它执行链接到Busybox的<code>cat_main()</code>函数.</p><div class="custom-container c-yellow"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-edit"></i> 运行Busybox</h4></span><p>尝试通过NTerm运行Busybox中的一些简单命令, 比如<code>cat</code>和<code>printenv</code>等. 如果你不清楚这些命令的用法, 可以通过<code>man</code>来查阅它们. 注意不要让这些命令的输出淹没在<code>hello_fun()</code>打印的信息中, 为此你可能需要调整<code>hello_fun()</code>打印信息的频率.</p></div><p>有一些工具并不是放在<code>/bin</code>目录下, 而是放在<code>/usr/bin</code>目录下, 例如<code>wc</code>. 为了不必输入完整的路径, 我们可以把<code>/usr/bin</code>也加入到<code>PATH</code>环境变量中. 不同的路径通过<code>:</code>进行分隔, 具体格式可以参考在Linux上运行<code>echo $PATH</code>命令的结果. 这样以后, 我们就可以通过一个库函数<code>execvp()</code>来尝试遍历<code>PATH</code>中的所有路径, 直到找到一个存在的可执行文件为止, 找到之后就会调用<code>SYS_execve</code>. 你可以通过阅读<code>navy-apps/libs/libc/src/posix/execvp.c</code>来了解这一功能是如何实现的.</p><p>不过为了遍历<code>PATH</code>中的路径, <code>execvp()</code>可能会尝试执行一个不存在的用户程序, 例如<code>/bin/wc</code>. 因此Nanos-lite在处理<code>SYS_execve</code>系统调用的时候就需要检查将要执行的程序是否存在, 如果不存在, 就需要返回一个错误码. 我们可以通过<code>fs_open()</code>来进行检查, 如果需要打开的文件不存在, 就返回一个错误的值, 此时<code>SYS_execve</code>返回<code>-2</code>. 另一方面, libos中的<code>execve()</code>还需要检查系统调用的返回值: 如果系统调用的返回值小于0, 则通常表示系统调用失败, 此时需要将系统调用返回值取负, 作为失败原因设置到一个全局的外部变量<code>errno</code>中, 然后返回<code>-1</code>.</p><div class="custom-container c-blue"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-comment-o"></i> -2和errno</h4></span><p><code>errno</code>是C标准定义的, 运行时环境中的一个全局变量, 用于存放最近一次失败的系统调用或库函数调用的错误码. 你可以通过运行<code>errno -l</code>命令(需要通过<code>apt-get</code>安装<code>moreutils</code>包) 来查看所有的错误码及其含义, 你应该能看到错误码<code>2</code>是你比较熟悉的一种错误. 关于<code>errno</code>全局变量的更多信息, 可以参考<code>man 3 errno</code>.</p></div><div class="custom-container c-yellow"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-edit"></i> 运行Busybox(2)</h4></span><p>实现上述内容, 让<code>execvp()</code>支持<code>PATH</code>的遍历. 然后尝试通过NTerm运行<code>wc</code>等位于<code>/usr/bin</code>目录下的命令, 例如<code>wc /share/games/bird/atlas.txt</code>. 你可以通过在Linux上运行相应命令来查看结果是否正确. 此外, 你可以通过阅读<code>execvp()</code>的代码来帮助你判断返回值的设置是否正确.</p></div><p>虽然目前我们只能在Nanos-lite上运行很少部分的Busybox工具, 但你基本上在自己构建的计算机系统里面呈现了与你平时使用Linux命令行工具非常相似的一幕. 我们把这件事放到Project-N的系统栈里面, 就是为了能够让你明白, 你平时键入命令的时候计算机系统的各个抽象层都做了些什么:</p><ul><li>终端如何读取用户的按键?</li><li>Shell如何进行命令的解析?</li><li>库函数如何根据命令解析出的字符串搜索到可执行文件?</li><li>操作系统如何加载执行一个可执行文件?</li><li>......</li></ul><p>虽然Project-N和真实的Linux系统还有很大的差异, 但独立完成PA已经可以很大程度上帮助你消除对&quot;程序如何在计算机上运行&quot;的神秘感.</p><div class="custom-container c-green"><span class="custom-container-title"><h4 style="display:inline;"><i class="fa fa-lightbulb-o"></i> 温馨提示</h4></span><p>PA4阶段1到此结束.</p></div></div><!--[--><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="4.2.html" class="" aria-label="程序和内存位置"><!--[--><!--]--> 程序和内存位置 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="../assets/app.4a525931.js" defer></script>
  </body>
</html>
